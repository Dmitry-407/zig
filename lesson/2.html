<!DOCTYPE html>
<html>
    <head>
        <link href="https://cwelth.com/gfx/summer-icon.png" rel="icon"/>
        <link href="/zig/font.css" rel="stylesheet" type="text/css"/>
        <link href="/zig/style.css" rel="stylesheet" type="text/css"/>
        <meta property="og:title" content="Урок #2"/>
        <meta property="vk:image"  content="https://dmitriy-407.github.io/zig/img/2.png"/>
        <meta charset="utf-8">
        <title>Руководство по моддингу</title>
        <script type="text/javascript" src="https://www.google.com/jsapi"></script>
        <script type="text/javascript">
            google.load("jquery", "1.3.2");
            google.load("jqueryui", "1.7.2");
        </script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
        <div class="content">
            <a href="/zig/">
                <div class="forg">
                <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Ebene_1" x="0px" y="0px" width="100%" height="100%" viewBox="0 0 316 66.7" style="enable-background:new 0 0 316 66.7;" xml:space="preserve">
                    <style type="text/css">
                        .st0{fill:#DFA86A;}
                        .st1{fill:#26303d;}
                    </style>
                    <g>
                        <g>
                            <polygon class="st0" points="114.1,55.6 125,55.6 125,38.7 143,38.7 143,28.4 125,28.4 125,21.4 144.1,21.4 144.1,11.1     114.1,11.1   "/>
                            <path class="st0" d="M185.3,16.3c-2.1-2.1-4.6-3.6-7.5-4.7c-2.7-1-5.8-1.5-9-1.5l-0.4,0c-3.4,0-6.5,0.6-9.3,1.7    c-2.9,1.1-5.4,2.7-7.4,4.8c-2.1,2.1-3.7,4.6-4.9,7.5c-1.2,2.9-1.7,6.1-1.7,9.6c0,3.4,0.6,6.6,1.8,9.4c1.2,2.8,2.8,5.3,4.9,7.3    c2.1,2,4.6,3.6,7.4,4.7c2.8,1.1,6,1.7,9.3,1.7h0h0c3.4,0,6.6-0.6,9.4-1.8c2.9-1.1,5.4-2.8,7.5-4.8c2.1-2,3.7-4.5,4.9-7.4    c1.2-2.8,1.8-6,1.8-9.4c0-3.5-0.6-6.7-1.7-9.6C189,20.9,187.3,18.4,185.3,16.3z M180.6,33.1c0,2-0.3,3.8-0.9,5.4    c-0.6,1.6-1.4,3-2.5,4.2c-1,1.1-2.3,2.1-3.8,2.7c-1.5,0.7-3.2,1-5,1c-1.8,0-3.5-0.3-5-1c-1.5-0.7-2.7-1.6-3.8-2.7    c-1.1-1.2-1.9-2.6-2.5-4.2c-0.6-1.6-0.9-3.5-0.9-5.4c0-1.8,0.3-3.5,0.9-5c0.6-1.5,1.4-2.9,2.5-4c1-1.1,2.3-2,3.8-2.7    c1.5-0.6,3.1-1,5-1c1.8,0,3.5,0.3,5,1c1.5,0.6,2.8,1.5,3.8,2.7c1.1,1.1,1.9,2.5,2.5,4C180.3,29.6,180.6,31.3,180.6,33.1z"/>
                            <path class="st0" d="M224.2,33.3c1.9-2.3,2.9-5.2,2.9-8.6c0-2.6-0.5-4.8-1.5-6.6c-1-1.8-2.4-3.2-4-4.2c-1.6-1-3.4-1.7-5.5-2.1    c-1.9-0.4-4-0.6-6-0.6h-16v44.5h11V38.3h2.3l9.4,17.3h13.1l-11.2-18.6C220.9,36.2,222.8,35,224.2,33.3z M204.9,21h4.4    c0.8,0,1.7,0.1,2.6,0.2c0.8,0.1,1.5,0.3,2.1,0.6c0.5,0.2,0.9,0.6,1.2,1c0.3,0.4,0.4,1,0.4,1.8c0,0.9-0.2,1.6-0.5,2.1    c-0.3,0.5-0.8,0.8-1.3,1c-0.7,0.3-1.5,0.5-2.3,0.6c-1,0.1-2,0.1-2.9,0.1h-3.8V21z"/>
                            <path class="st0" d="M242.7,24c1-1.1,2.3-2,3.8-2.7c1.5-0.6,3.1-1,5-1c1.8,0,3.6,0.3,5.3,0.9c1.6,0.6,3,1.4,4.1,2.5l1.3,1.3l8-8.1    l-1.5-1.3c-2.4-2.1-5.1-3.6-8.1-4.4c-2.9-0.8-6-1.2-9.2-1.2c-3.4,0-6.5,0.6-9.3,1.7c-2.9,1.1-5.4,2.7-7.4,4.8    c-2.1,2.1-3.7,4.6-4.9,7.5c-1.2,2.9-1.7,6.1-1.7,9.6c0,3.4,0.6,6.6,1.8,9.4c1.2,2.8,2.8,5.3,4.9,7.3c2.1,2,4.6,3.6,7.4,4.7    c2.8,1.1,6,1.7,9.3,1.7c6.5,0,12.5-1.4,17.8-4.3l1-0.5V28h-19.3v10.3h8.4V45c-0.9,0.4-1.8,0.7-2.9,0.9c-1.5,0.3-3.1,0.5-4.8,0.5    c-1.8,0-3.5-0.3-5-1c-1.5-0.7-2.7-1.6-3.8-2.7c-1.1-1.2-1.9-2.6-2.5-4.2c-0.6-1.6-0.9-3.5-0.9-5.4c0-1.8,0.3-3.5,0.9-5    C240.9,26.5,241.7,25.1,242.7,24z"/>
                            <polygon class="st0" points="285.6,45.3 285.6,38 304.3,38 304.3,27.7 285.6,27.7 285.6,21.4 305.4,21.4 305.4,11.1 274.6,11.1     274.6,55.6 306.4,55.6 306.4,45.3   "/>
                        </g>
                        <path class="st1" d="M91.6,16.7l-37.8-1.9l46.2,0v-3.7H47.8l0,7.8v6.2c0,0.1-1.5-9.1-1.9-11.7h-4.1v6.8v6.2   c0,0.1-1.8-10.9-1.9-12.3c-10.4,0-27.9,0-27.9,0c1.9,1.6,12.4,10.6,19.9,14.3c3.7,1.8,8.3,1.9,12.4,2c2.1,0.1,4.2,0.2,5.8,1.8   c2.3,2.2,2.8,5.7,0.8,8.3c-1.9,2.6-7.3,3.2-7.3,3.2L39,49.1v6.4h10.3l0.3-6.3l8.9-6.3c-0.9,0.8-3.1,2.8-6.2,7.7   c-0.7,1.1-1.3,2.3-1.7,3.5c2.2-1.9,6.8-3.2,12.2-3.2c5.3,0,9.9,1.3,12.1,3.2c-0.4-1.2-1-2.4-1.7-3.5c-3.2-4.9-5.3-6.9-6.2-7.7   l8.9,6.3l0.3,6.3h9.6v-6.4l-4.5-5.5c0,0-6.7-0.4-8.4-3.2C67.7,32.6,74.8,20.4,91.6,16.7z"/>
                    </g>
                    </svg>
                </div>
                <h1>Руководство по моддингу</h1>
            </a>
            <div class="body--content">
                <div class="lesson-header">
                    <p class="img" style="background-image: url(https://www.minecraft.net/etc.clientlibs/minecraft/clientlibs/main/resources/img/menu/menu-store.svg)"></p>
                    <h1>Урок #2</h1>
                </div>
                <h4>И здравствуйте, уважаемые</h4>
                <p>С вами ZigTheHedge и сегодня мы научимся структурировать свой мод, и сделаем простейший предмет</p>
                <p>Учитывая, что я пишу статьи, как отдельный учебник, крайне советую прочесть первую статью. Так как сегодня мы будем использовать названия и договоренности <a href="/zig/lesson/1">из первой статьи</a>. Напоминаю: наш мод называется <b>tutorial</b>, и подписан он каноническим именем <b>ru.zigthehedge</b>. И, держа эту информацию в голове, давайте начнем</p>
                <p><b>Откроем IDEA и загрузим наш проект</b><br>Слева у нас будет панель, в которой открыт наш проект. И там мы видим все файлы, которые находятся в каталоге с проектом, а также свернутый список <b>"External Libraries"</b> <span style="color: #ccc">(внешние библиотеки)</span>. Если открыть список <b>"External Libraries"</b> мы увидим все библиотеки, которые привязаны к проекту магическими силами <b>Gradle</b>. Из всего списка нас может заинтересовать библиотека <b>forgeSrc-1.12.2-версия_forge.jar</b> - это сам forge, и там же находятся декомпилированные исходники майнкрафта! Да-да! Именно открыв эту библиотеку, мы можем посмотреть, что из себя представляет майнкрафт изнутри!</p>
                <p class="imag" style="background-image: url(https://pp.userapi.com/c858028/v858028000/1797c/JyemlVTMTtQ.jpg); height: 800px;" onclick="image('https://pp.userapi.com/c858028/v858028000/1797c/JyemlVTMTtQ.jpg')"></p>
                <p>Зачем я вам про это рассказал? Дело в том, что ванилла - это один из лучших источников, к которым следует обращаться, если вы зашли в тупик и не знаете, как сделать какую-то механику. Просто вспомните, какой блок, предмет, моб, или механизм в ванильном майнкрафте имеет функционал схожий с тем, которого пытаетесь добиться вы, и найдите его исходники в ванилле. Зачастую, там можно сломать шею, но со временем вы привыкнете</p>
                <p>Возвращаемся к нашему основному проекту, и поговорим о необходимых для любого мода требованиях. Во-первых, любой мод имеет <b>главный класс</b>. Этот класс загружается forge'ем при старте майнкрафта с вашим модом, и уже этот класс определяет то, как будет работать ваш мод. Называть класс можно, разумеется, как угодно, но, для собственного удобства, а так же для удобства тех, кто будет читать ваш код, <b>главный класс принято именовать так же, как у вас называется сам мод</b> и располагать его в корне проекта</p>
                <p class="warn">Классы в <b>Java</b>, по соглашению, называются в <b>CamelCase</b> с заглавной первой буквой</p>
                <p class="imag" style="background-image: url(https://pp.userapi.com/c858028/v858028000/17984/cBD2gydSE7g.jpg); height: 700px;" onclick="image('https://pp.userapi.com/c858028/v858028000/17984/cBD2gydSE7g.jpg')"></p>
                <p>Выберем наш <b>package</b> <span style="color: #ccc">(модное название каталогов в <b>Java</b>)</span>, нажмем правый клик и выберем <b>"New -> Java Class"</b></p>
                <p>Зададим имя нашему главному классу. Впишем в поле <b>"Name"</b> значение: <b>"Tutorial"</b>. Нажем <b>"Ok"</b><br>У нас создался класс, в котором, собственно, ничего нет. И вот здесь мы, наконец, начинаем программировать. Правда, сначала нам надо создать <b>"скелет"</b> нашего мода. Создадим в нашем новом классе <b>3 свойства</b></p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/tutorial" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--orang">public class</span> Tutorial {<br>
                    <div><span class="color--orang">public static final</span> String <span class="color--violet">MODID</span> = <span class="color--green">"tutorial"</span><span class="color--orang">;</span><br>
                        <span class="color--orang">public static final</span> String <span class="color--violet">NAME</span> = <span class="color--green">"Tutorial Mod"</span><span class="color--orang">;</span><br>
                        <span class="color--orang">public static final</span> String <span class="color--violet">VERSION</span> = <span class="color--green">"1.0"</span><span class="color--orang">;</span></div>
                    }
                </div>
                <p class="warn">Тремя точками я буду обозначать места в файлах, где уже может быть что-то написано, что не важно конкретно «сейчас». Это общепринятая практика, так что — привыкайте</p>
                <div class="info">Что мы здесь написали? Мы создали три публичных статических неизменяемых переменных типа <b>«String»</b>. Рассказать вам, что означают эти прилагательные? Окей:
                    <ul>
                        <li><b>public</b> — публичный доступ. Означает, что к этому элементу можно обращаться из любых мест кода <span style="color: #ccc">(изо всех классов и их методов)</span></li>
                        <li><b>static</b> — статический признак. Означает, что в памяти для любого количества экземпляров объекта выделяется одна и та же ячейка. Соответственно <span style="color: #ccc">(в случае с переменной)</span> ее значение будет всегда одним и тем же для всех экземпляров классов. Это экономит память и позволяет обращаться к объекту без создания экземпляра класса</li>
                        <li><b>final</b> — неизменяемое значение. Значение этого объекта нельзя изменить после инициализации</li>
                        <li><b>String</b> - это стандартный класс <b>java</b> для описание строк</li>
                    </ul>
                </div>
                <p>Теперь про сами переменные. Они содержат в себе техническое название мода (MODID), человеческое название мода <b>(NAME)</b> и версию мода <b>(VERSION)</b>. Удостоверьтесь, чтобы значения <b>MODID</b> и <b>VERSION</b> совпадали со значениями в <b>build.gradle</b>!</p>
                <p>Далее, нам необходимо сказать forge'у, что этот вот класс является главным для нашего мода. Для этого служит аннотация из <b>forge</b> под названием <b>@Mod</b>. Давайте добавим ее непосредственно перед объявлением нашего главного класса:</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/tutorial" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--yellow">@Mod</span>(<span class="color--violet--2">modid</span> = Tutorial.<span class="color--violet">MODID</span>, <span class="color--violet--2">name</span> = Tutorial.<span class="color--violet">NAME</span>, <span class="color--violet--2">version</span> = Tutorial.<span class="color--violet">VERSION</span>)<br>
                    <span class="color--orang">public class</span> Tutorial {<br>
                    ...
                </div>
                <p class="error"><b>Ииии… Вау! Куча красных строк! Куча ошибок! Аааа! Зиг все сломал!</b></p>
                <p>Вот здесь начинаются отличия в средах разработки. Дело в том, что эта аннотация не из java. Она предоставляется forge'ем. Соответственно, нам надо сказать компилятору, где ее искать. Для этого в java служат конструкции вида <b>«import package»</b></p>
                <p>Если вы разрабатываете в <b>IDEA</b>, просто поставьте курсор на <b>@Mod</b>, который подсвечен красным, и нажмите <b>Alt+Enter</b></p>
                <p class="imag" style="background-image: url(https://pp.userapi.com/c858028/v858028000/179c9/zCLQJ8II4gA.jpg); height: 200px;" onclick="image('https://pp.userapi.com/c858028/v858028000/179c9/zCLQJ8II4gA.jpg')"></p>
                <p>Из меню выберите <b>«Import class»</b>. И, магическими силами <b>IDEA</b>, в ваш класс добавятся все необходимые import'ы <span style="color: #ccc;">(в нашем случае, только один)</span>. В итоге, наш класс будет выглядеть вот так <span style="color: #ccc;">(без троеточий)</span>:</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/tutorial" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    <span class="color--orang">package</span> ru.zigthehedge.tutorial<span class="color--orang">;</span><br>
                    <br>
                    <span class="color--orang">import</span> net.minecraftforge.fml.common.<span class="color--yellow">Mod</span><span class="color--orang">;</span><br>
                    <br>
                    <span class="color--yellow">@Mod</span>(<span class="color--violet--2">modid</span> = Tutorial.<span class="color--violet">MODID</span>, <span class="color--violet--2">name</span> = Tutorial.<span class="color--violet">NAME</span>, <span class="color--violet--2">version</span> = Tutorial.<span class="color--violet">VERSION</span>)<br>
                    <span class="color--orang">public class</span> Tutorial {<br>
                        <div><span class="color--orang">public static final</span> String <span class="color--violet">MODID</span> = <span class="color--green">"tutorial"</span><span class="color--orang">;</span><br>
                        <span class="color--orang">public static final</span> String <span class="color--violet">NAME</span> = <span class="color--green">"Tutorial Mod"</span><span class="color--orang">;</span><br>
                        <span class="color--orang">public static final</span> String <span class="color--violet">VERSION</span> = <span class="color--green">"1.0"</span><span class="color--orang">;</span></div>
                    }
                </div>
                <p class="warn">Если у вас по нажатию <b>Alt+Enter</b> нет пункта <b>«Import class»</b>, значит вы не подключили библиотеки <b>Forge</b> и дальше разрабатывать мод не получится. Вернитесь к первой статье и проделайте все процедуры более внимательно!</p>
                <p>Теперь нам надо создать еще два класса. Это так называемые <b>proxy-классы</b>. Сначала я расскажу, зачем они нужны, а потом приступим к созданию</p>
                <p>Дело в том, что ваш мод будет выполняться одновременно <b>в двух контекстах</b>: на <b>стороне клиента</b> и на <b>стороне сервера</b> <span style="color: #ccc;">(даже если вы просто запускаете у себя в майнкрафте одиночную игру, у вас все равно запускается встроенный в майнкрафт сервер)</span>. А эти контексты различаются набором доступных классов. Например, серверная часть ничего не знает о выводе изображений на экран (у него просто нет экрана!). Для этого, чтобы не писать два мода, как это было во времена <b>1.2.5</b>, был придуман способ <b>логически разделять стороны</b>, и мод в итоге получается универсальным и для клиента и для сервера</p>
                <p>Разделение будет присутствовать во многих частях мода, но начинается оно как раз с прокси-классов. Давайте их создадим: проведите аналогичные действия по созданию класса, как вы это делали при создании главного класса, и создайте классы <b>CommonProxy</b> и <b>ClientProxy</b></p>
                <p class="imag" style="background-image: url(https://pp.userapi.com/c858028/v858028000/17a11/fxK_V5RKRFY.jpg); height: 200px;" onclick="image('https://pp.userapi.com/c858028/v858028000/17a11/fxK_V5RKRFY.jpg')"></p>
                <p>Откройте класс <b>ClientProxy</b> и в строке его объявления допишите <b>«extends CommonProxy»</b></p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/clientproxy" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    <span class="color--orang">package</span> ru.zigthehedge.tutorial<span class="color--orang">;</span><br>
                    <br>
                    <span class="color--orang">public class</span> ClientProxy <span class="color--orang">extends</span> CommonProxy {<br>
                    }
                </div>
                <p class="warn">Такой подход хоть и рекомендуется самим <b>Forge</b>, но является немного нелогичным. В основе разделения должны быть классы <b>ServerProxy</b> <span style="color: #ccc">(в котором будет код, который выполняется исключительно на стороне сервера)</span> и <b>ClientProxy</b> <span style="color: #ccc">(код которого выполняется исключительно на стороне клиента)</span>. Мы же создаем класс, общий для клиента и сервера <span style="color: #ccc">(<b>CommonProxy</b>)</span> и отдельный класс для клиента <b>ClientProxy</b>, который будет включать в себя и код из <b>CommonProxy</b></p>
                <p>Теперь нам надо сказать нашему моду, что у него есть прокси. Делается это в главном классе при помощи следующей аннотации</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/commonproxy" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                        <div><span class="color--orang">public static final</span> String <span class="color--violet">VERSION</span> = <span class="color--green">"1.0"</span><span class="color--orang">;</span><br>
                        <span class="color--yellow">@SidedProxy</span>(<span class="color--violet--2">clientSide</span> = <span class="color--green">"ru.zigthehedge.tutorial.ClientProxy"</span><span class="color--orang">,</span> <span class="color--violet--2">serverSide</span> = <span class="color--green">"ru.zigthehedge.tutorial.CommonProxy"</span>)<br>
                        <span class="color--orang">public static</span> CommonProxy <span class="color--violet">proxy</span><span class="color--orang">;</span></div>
                    }
                </div>
                <p>Не забывайте про <b>Alt+Enter</b>, чтобы добавить недостающие import'ы при использовании <b>@SidedProxy</b></p>
                <p>Значение параметров <b>clientSide</b> и <b>serverSide</b> в аннотации указывают на полный путь до <b>прокси-классов</b> клиента и сервера. Создание статического экземпляра класса <b>CommonProxy</b> непосредственно после аннотации, дает понять компилятору, что в этом свойстве будет находиться ссылка на <b>ClientProxy</b>, если мод запускается <b>на стороне клиента</b>, и на <b>CommonProxy</b>, если мод запускается <b>на стороне сервера</b></p>
                <p class="warn">Можно создать отдельный <b>ServerProxy</b> класс, который будет наследовать <b>CommonProxy</b>, чтобы он использовался на стороне сервера, но, на моей практике, ни разу не возникало такой необходимости, так как я не сталкивался с методами, которые существуют только на стороне сервера</p>
                <p>Теперь давайте развяжем стороны для трех главных событий <b>Forge</b></p>
                <p class="info">Почти каждое действие в майнкрафте дублируется соответствующим событием. <b>Событие</b> — это механика майнкрафта, которое позволяет коду «подписываться» на действия. То-есть, например, игрок теряет здоровье, когда падает с высоты. Значит, есть часть кода, которая подписана на событие "игрок упал", проверяет высоту, с которой игрок упал и, если высота больше безопасной, и у игрока нет зачарования на Feather Falling, отнимает у игрока сердечки. На событиях завязана вся логика майнкрафта, и это чертовски удобно! Главное, втянутся в саму суть событий</p>
                <p>Итак, события. Есть три события, которые <b>Forge</b> отправляет всем подписаным модам при загрузке майнкрафта. Это <b>FMLPreInitializationEvent</b>, <b>FMLInitializationEvent</b> и <b>FMLPostInitializationEvent</b>. Если вы когда-нибудь следили за полоской загрузки модов в сборке, вы видели там надписи <b>«Pre-init Phase»</b>, <b>«Init Phase»</b> и <b>«Post-init Phase»</b>. Это как раз и есть действия, которые инициируют вышеобозначенные события. Ответом на эти события, моды регистрируют свои внутренние механики, задают экземпляры классов с подпиской на другие события, регистрируют пользовательские интерфейсы блоков, регистрируют сетевые пакеты и прочее служебное добро, которое будет необходимо для работы мода. Для начала, давайте создадим в наших прокси-классах методы, которые будут вызываться в ответ на полученное событие. В классе <b>CommonProxy</b> создадим методы</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/commonproxy" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--orang">public class</span> CommonProxy {<br>
                        <div><span class="color--orang">public void</span> <span class="color--orang--2">preInit</span>(FMLPreInitializationEvent e)<br>
                        {<br>
                        }<br>
                            <span class="color--orang">public void</span> <span class="color--orang--2">init</span>(FMLInitializationEvent e)<br>
                        {<br>
                        }<br>
                            <span class="color--orang">public void</span> <span class="color--orang--2">postInit</span>(FMLPostInitializationEvent e)<br>
                        {<br>
                        }</div>
                    }
                </div>
                <p>Не забываем про импорт соответствующих модулей <span style="color: #ccc;">(<b>Alt</b> + <b>Enter</b>)</span></p>
                <p class="warn">Cовершенно неважно, как вы назовете методы. Главное — <b>это типы их входных параметров</b>. Я назвал методы по типам фаз, на события которых мы подписываемся</p>
                <p>Теперь перегрузим эти же методы в <b>ClientProxy</b>. Нужно это для того, чтобы клиентская сторона мода и серверная сторона мода по-разному реагировали на эти события. А, учитывая то, что наш <b>ClientProxy</b> наследует методы <b>CommonProxy</b>, мы можем открыть наш <b>ClientProxy</b> и воспользоваться удобным механизмом для перегрузок нашей <b>IDEA</b>. Поставим курсор в <b>>«тело»</b> класса и нажмем <b>Ctrl+O</b></p>
                <p class="imag" style="background-image: url(https://pp.userapi.com/c858028/v858028567/15ff4/qUAfufgojKY.jpg); height: 600px;" onclick="image('https://pp.userapi.com/c858028/v858028567/15ff4/qUAfufgojKY.jpg')"></p>
                <p><b>IDEA</b> нам показала список методов, которые можно перегрузить. Нас интересуют три: <b>preInit</b>, <b>init</b> и <b>postInit</b>. Ведь именно так мы назвали методы в нашем <b>CommonProxy</b>. Выбираем их все и нажимаем <b>«Ok»</b>. Наш класс клиентского прокси преобразился автоматически в нечто подобное:</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/clientproxy" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    <span class="color--orang">package</span> ru.zigthehedge.tutorial<span class="color--orang">;</span><br>
                    <br>
                    <span class="color--orang">import</span> net.minecraftforge.fml.common.event.FMLInitializationEvent<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraftforge.fml.common.event.FMLPostInitializationEvent<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraftforge.fml.common.event.FMLPreInitializationEvent<span class="color--orang">;</span><br>
                    <br>
                    <span class="color--orang">public class</span> ClientProxy <span class="color--orang">extends</span> CommonProxy {<br>
                        <div><span class="color--yellow">@Override</span><br>
                        <span class="color--orang">public void</span> <span class="color--orang--2">preInit</span>(FMLPreInitializationEvent e) {<br>
                            <div><span class="color--orang">super</span>.preInit(e);</div>
                        }<br>
                        <span class="color--yellow">@Override</span><br>
                        <span class="color--orang">public void</span> <span class="color--orang--2">init</span>(FMLInitializationEvent e) {<br>
                            <div><span class="color--orang">super</span>.init(e);</div>
                        }<br>
                        <span class="color--yellow">@Override</span><br>
                        <span class="color--orang">public void</span> <span class="color--orang--2">postInit</span>(FMLPostInitializationEvent e) {<br>
                            <div><span class="color--orang">super</span>.postInit(e)<span class="color--orang">;</span></div>
                        }</div>
                    }
                </div>
                <p class="warn">Аннотация <b>@Override</b> скорее избавляет нас от невнимательности, чем несет какое-то более важное значение. Компилятор ругнется на ошибку, если наш метод, который аннотирован как <b>@Override</b> по факту ничего не перегружает. Это помогает избежать ошибок, если вы перегружаете методы вручную</p>
                <p>Теперь давайте подпишем наш мод на получение этих событий. Делается это в главном классе мода:</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/tutorial" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--yellow">@Mod.EventHandler</span><br>
                    <span class="color--orang">public void</span> preInit(FMLPreInitializationEvent e)<br>
                    {<br>
                        <div><span class="color--violet">proxy</span>.preInit(e)<span class="color--orang">;</span></div>
                    }<br>
                    <span class="color--yellow">@Mod.EventHandler</span><br>
                    <span class="color--orang">public void</span> init(FMLInitializationEvent event) <br>
                    {<br>
                        <div><span class="color--violet">proxy</span>.init(event)<span class="color--orang">;</span></div>
                    }<br>
                    <span class="color--yellow">@Mod.EventHandler</span><br>
                    <span class="color--orang">public void</span> postInit(FMLPostInitializationEvent e)<br>
                    {<br>
                        <div><span class="color--violet">proxy</span>.postInit(e)<span class="color--orang">;</span></div>
                    }<br>
                    ...
                </div>
                <p>Аннотация <b>@Mod.EventHandler</b> используется для того, чтобы рассказать <b>Forge</b> о том, что именно последующий метод класса надо вызвать, когда возникает событие. Опять же - <b>названия методов не важны</b>, важны <b>типы входящих параметров</b></p>
                <p>В обработчиках событий <span style="color: #ccc;">(тела наших новых методов)</span> мы вызываем соответствующие методы из прокси-классов. <b>Forge</b> автоматически вызовет методы из <b>ClientProxy</b>, если мод работает на стороне клиента, и из <b>CommonProxy</b>, если на стороне сервера</p>
                <p>Ну вот. Костяк нашего мода мы сделали. Теперь можно приступить к созданию предмета</p>
                <p class="warn">Когда я только начинал учиться разрабатывать моды, и сам читал руководства, мне всегда было непонятно - почему сначала рассматривают предмет, а не блок? Очень скоро ответ на этот вопрос становится очевидным ;)</p>
                <p>Итак. Давайте создадим класс для нашего предмета</p>
                <p class="warn">Если мы создаем предмет, который ничего не делает и использоваться будет исключительно как компонент в рецептах, мы можем не создавать свой класс, а воспользоваться ванильным, но, я сразу хочу, чтобы вы создали свой класс, чтобы Вы <b>уже понимали</b>, как работать с различными механиками предметов, когда это вам действительно понадобится</p>
                <p>Назовем класс <b>«техническим именем»</b> нашего предмета. Допустим, мы хотим создать ключ от замка! Неожиданно, правда? Имя класса будет в представлять собой что-то вроде <b>Key</b>. Но! Не спешите тыкать по проекту. В рамках этого туториала, мы создадим всего один предмет, но в вашем реальном моде количество разных предметов может исчисляться десятками, а то и сотнями! Поэтому, давайте для наших предметов создадим свой <b>package</b> <span style="color: #ccc">(то-есть, подкаталог)</span></p>
                <p class="imag" style="background-image: url(https://pp.userapi.com/c858028/v858028899/17bb6/GZcDiH1mPRc.jpg); height: 300px;" onclick="image('https://pp.userapi.com/c858028/v858028899/17bb6/GZcDiH1mPRc.jpg')"></p>
                <p>В качестве имени нашего нового пакета, используем слово <b>«items»</b>. Что весьма логично</p>
                <p class="warn">Пакеты принято называть в <b>snake_case</b></p>
                <p>В получившемся пакете уже можно создать наш класс для предмета</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/items/key" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    <span class="color--orang">package</span> ru.zigthehedge.tutorial.items<span class="color--orang">;</span><br>
                    <span class="color--orang">public class</span> Key {<br>
                    }<br>
                </div>
                <p>Далее, мы хотим создать предмет, а это уже готовый ванильный класс. Поэтому, чтобы не переписывать всю внутреннюю логику работы с предметом, имеет смысл унаследовать оригинальный класс и перегрузить те методы, которые необходимы именно для нашего предмета. Добавляем к объявлению класса <b>«extends Item»</b>:</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/items/key" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--orang">import</span> net.minecraft.item.Item<span class="color--orang">;</span><br>
                    <br>
                    <span class="color--orang">public class</span> Key <span class="color--orang">extends</span> Item {<br>
                    <br>
                    }<br>
                </div>
                <p>Теперь нам необходимо как-то отличать наш предмет от остальных. В <b>Forge</b> для этого используется механизм <b>«регистров»</b> <span class="color #ccc;">(registers) (не пугайтесь, это не те регистры, которые находятся внутри процессора, это скорее коллекция всех предметов, блоков, измерений, жидкостей и так далее)</span>. И, чтобы отличать предметы друг от друга внутри этих регистров, используются <b>«регистровые имена»</b>. <span class="color: #ccc;">(register names)</span>. Как правило, они для удобства совпадают с названием классов, однако, буквы должны всегда быть в <b>нижнем регистре</b> и из спец-символов разрешено только <b>«нижнее подчеркивание»</b> <span class="color: #ccc;">(то-есть, снова snake_case)</span></p>
                <p>Чтобы нам задать регистровое имя для нашего предмета, создадим <b>конструктор</b> нашего класса и напишем там необходимый код:</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/items/key" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--orang">public class</span> Key <span class="color--orang">extends</span> Item {<br>
                        <div>
                            <span class="color--orang">public</span> <span class="color--orang--2">Key</span> ()<br>
                            {<br>
                            <div>setRegistryName(<span class="color--green">"key"</span>)<span class="color--orang">;</span><br>
                                setUnlocalizedName(Tutorial.<span class="color--violet">MODID</span> + <span class="color--green">".key"</span>)<span class="color--orang">;</span><br>
                                setCreativeTab(CreativeTabs.<span class="color--violet">MISC</span>)<span class="color--orang">;</span></div>
                            }<br>
                        </div>
                </div>
                <p class="info"><b>Конструктор</b> - это метод класса, не имеющий никакого типа возвращаемого значения, и вызываемый автоматически при создании экземпляра класса</p>
                <p>Метод <b>setRegistryName</b> задает регистровое имя для нашего предмета, а метод <b>setUnlocalizedName</b> — регистровое имя для локализации названия предмета. В майнкрафте именно таким образом реализован механизм локализации. То-есть, именно это <b>«нелокализованное»</b> имя будет искаться в <b>языковых файлах</b>, когда клиенту нужно будет вывести название предмета на экран. В <b>«нелокализованном имени»</b> так же указывается техническое имя нашего мода и, через точку, регистровое имя предмета</p>
                <p>И, чтобы мы с вами смогли отыскать наш предмет в игре, я добавил вызов метода <b>setCreativeTab()</b>. Он добавляет наш предмет в одну из вкладок креативного инвентаря. В моем случае в <b>Misc</b>. Именно это означает параметр вызова этого метода <b>CreativeTabs.MISC</b></p>
                <p>Мы создали класс предмета. Теперь его необходимо <b>зарегистрировать</b> и создать экземпляр, который и будет использоваться в дальшейшем в моде</p>
                <p>Обычно, все экземпляры предметов и блоков мода хранятся в отдельных классах. Давайте создадим такой класс для предметов. Назвать класс можно как угодно, но я предпочитаю называть его <b>именем мода + словом Items</b>. Таким образом, мы сможем отличить наш класс от классов других модов и ваниллы. Так что, создадим класс <b>TutorialItems</b>. Создавать его будем в пакете <b>items</b></p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/items/tutorialitems" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    <span class="color--orang">package</span> ru.zigthehedge.tutorial.items<span class="color--orang">;</span><br>
                    <span class="color--orang">public class</span> TutorialItems {<br>
                    }
                </div>
                <p>Внутри класса создадим <b>указатель</b> на экземпляр нашего нового предмета с аннотацией <b>@GameObject</b>. Это аннотация от <b>Forge</b>, которая позволяет ему указать, что в свойстве, следующим за аннотацией, содержится экземпляр класса с игровым объектом. Почему я сказал <b>«указатель»</b>? Потому что мы по факту не создаем экземпляр, а только назначаем переменную. Само создание будет немного потом</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/items/tutorialitems" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--orang">public class</span> TutorialItems {<br>
                        <div><span class="color--yellow">@</span>GameRegistry.<span class="color--yellow">ObjectHolder</span>(Tutorial.<span class="color--violet">MODID</span> + <span class="color--green">":key"</span>)<br>
                            <span class="color--orang">public static</span> Key <span class="color--violet">key</span><span class="color--orang">;</span></div>
                    }
                </div>
                <p>В качестве аргумента для аннотации используется конструкция: техническое имя мода, двоеточие, регистровое имя объекта. В нашем случае — предмета</p>
                <p>За аннотацией следует создание публичного статичного свойства с типом нашего класса</p>
                <p class="info">Имена предметам и блокам обычно дают в <b>UPPERCASE</b>, однако, я предпочитаю <b>camelCase</b> <span style="color: #ccc">(то-есть, такой же <b>CamelCase</b>, как обычно, но со строчной буквой в начале)</span>, а <b>UPPERCASE</b> храню для <b>final-переменных</b></p>
                <p>Чтож, мы создали экземпляр нашего предмета, однако теперь нам нужно <b>зарегистрировать</b> <span style="color: #ccc;">(буквально — поместить в <b>forge-регистр</b>)</span> и присвоить ему модель. Давайте начнем со второго. В нашем <b>TutorialItems</b> классе создадим еще один метод:</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/items/key" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--orang">public static</span> Key <span class="color--violet">key</span><span class="color--orang">;</span><br>
                    <span class="color--yellow">@SideOnly</span>(Side.<span class="color--violet">CLIENT</span>)<br>
                    <span class="color--orang">public static void</span> <span class="color--orang--2">initModels()</span> {<br>
                    }<br>
                    ...
                </div>
                <p>Методу предшествует аннотация <b>@SideOnly</b>. Эта аннотация включает метод только для определенной стороны. И ее удобно использовать, чтобы не включать исполнение в серверную часть мода. Для этого мы указываем в качестве аргумента <b>Side.CLIENT</b></p>
                <p>Сам метод является статическим и будет вызываться из наших прокси для того, чтобы присвоить предметам модель</p>
                <p>Однако, нам необходимо еще и сам метод создания модели описать. Перейдем в класс с нашим предметом <span style="color: #ccc;">(то-бишь, в <b>Key</b>)</span> и добавим метод для регистрации модели предмета:</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/items/key" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--yellow">@SideOnly</span>(Side.<span class="color--violet">CLIENT</span>)<br>
                    <span class="color--orang">public void</span> <span class="color--orang--2">initModels()</span> {<br>
                    <div>ModelLoader.setCustomModelResourceLocation(<span class="color--orang">this,</span> <span class="color--blue">0</span><span class="color--orang">, new</span> ModelResourceLocation(getRegistryName(), <span class="color--green">"inventory"</span>));</div>
                    }<br>
                    ...
                </div>
                <p>В этом методе мы вызываем класс <b>Forge</b>, который отвечает за модели всего в игре. В том числе и за модели предметов. Далее, при помощи статического метода <b>setCustomModelResourceLocation</b>, мы указываем, что текущий предмет <b>(this)</b> в варианте с индексом ноль <b>(0)</b> должен искать модель по параметрам текущего регистрового имени <span style="color: #ccc;">(<b>getRegistryName()</b> любезно нам его вернет)</span> в ванианте для <b>«inventory»</b> <span style="color: #ccc">(то-есть, для инвентаря)</span></p>
                <p>Теперь вызов этого нашего метода необходимо поместить в метод <b>initModels</b> нашего класса с предметами <b>TutorialItems</b></p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/items/key" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--orang">public static void</span> <span class="color--orang--2">initModels()</span> {<br>
                    <div><span class="color--violet">key</span>.initModel();</div>
                    ...<br>
                </div>
                <p class="warn">Наш метод не является статическим. И для его вызова необходим созданный нами ранее экземпляр класса с предметом</p>
                <p>Теперь мы, наконец, готовы зарегистрировать наш предмет в <b>Forge</b>. Для этого вернемся к классу общего прокси <b>CommonProxy</b>. Во-первых, нам надо добавить аннотацию <b>@Mod.EventBusSubscriber</b> перед объявлением класса, чтобы дать понять <b>Forge</b>, что этот класс будет <b>подисываться</b> на сообщения</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/commonproxy" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--yellow">@Mod.EventBusSubscriber</span><br>
                    <span class="color--orang">public class</span> CommonProxy {<br>
                    <div><span class="color--orang">public void</span> <span class="color--orang--2">preInit</span>(FMLPreInitializationEvent e)<br>
                        {</div>
                    ...
                </div>
                <p>И создать метод, который и будет подписан на сообщение о фазе регистрации предметов в игре</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/commonproxy" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--yellow">@SubscribeEvent</span><br>
                    <span class="color--orang">public static void</span> registerItems(RegistryEvent.Register&lt;Item&gt; event) {<br>
                    }<br>
                    ...<br>
                </div>
                <p>Я назвал метод <b>registerItems</b>, чтобы было понятнее, что именно он делает. Тип сообщения, на которое подписывается метод — <b>RegistryEvent.Register&lt;Item&gt;</b> — то-есть, <b>регистрации объектов</b> типа <b>Item</b>. И не забываем, что все методы, которые подписываются как обработчик сообщений, должны быть аннотированы при помощи <b>@SubscribeEvent</b></p>
                <p>Мы подписались на сообщение. Теперь нам надо на него отреагировать! В нашем случае, когда <b>Forge</b> предлагает модам зарегистрировать свои предметы, нам необходимо зарегистрировать свой. Сделать это просто. В <b>registerItems</b> добавим строчку:</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/commonproxy" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--yellow">@SubscribeEvent</span><br>
                    <span class="color--orang">public static void</span> registerItems(RegistryEvent.Register&lt;Item&gt; event) {<br>
                    <div>event.getRegistry().register(<span class="color--orang">new</span> Key())<span class="color--orang">;</span></div>
                    }<br>
                    ...
                </div>
                <p>Мы берем событие, которое к нам прилетело <b>(event)</b>, запрашиваем из этого события регистр <b>(getRegistry())</b> и этот регистр просим зарегистрировать <b>(register())</b> экземпляр нашего предмета</p>
                <p>Теперь нам надо откуда-то вызвать метод <b>TutorialItems.initModels</b>. Модели предметов, равно как и их регистрация, создаются в определенную фазу по определенному событию. Однако, модели — вещь исключительно клиентская <span style="color: #ccc;">(серверу абсолютно без разницы, как выглядит предмет и какая у него текстура)</span> поэтому, отредактируем наш <b>ClientProxy</b>:</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/clientproxy" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--yellow">@Mod.EventBusSubscriber</span>(Side.<span class="color--violet">CLIENT</span>)<br>
                    <span class="color--orang">public class</span> ClientProxy <span class="color--orang">extends</span> CommonProxy {<br>
                    <div><span class="color--yellow">@Override</span><br>
                        <span class="color--orang">public void</span> <span class="color--orang--2">preInit</span>(FMLPreInitializationEvent e) {</div>
                    ...
                </div>
                <p>Добавим аннотацию перед определением класса, чтобы класс мог подписываться на события</p>
                <p class="warn">В этот раз я указал сторону <b>(Side.CLIENT)</b> в аннотации. Это даст понять <b>Forge</b>, что этот класс может подписываться только на клиентские события</p>
                <p>И добавим сам метод с подпиской на событие о регистрации моделей:</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/clientproxy" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    ...<br>
                    <span class="color--yellow">@SubscribeEvent</span><br>
                    <span class="color--orang">public static void</span> registerModels(ModelRegistryEvent event) {<br>
                        <div>TutorialItems.initModels()<span class="color--orang">;</span></div>
                    }
                </div>
                <p>Я назвал метод <b>registerModels</b>, хотя, как я уже в который раз повторяю, имя метода не играет роли. Главное, чтобы вам самим было понятно, что он делает. Ну и, по возможности, не забывайте о тех людях, которые вам будут помогать <b>отлаживать</b> ваш код</p>
                <p class="info">Мне очень нравится глагол <b>"отлаживать"</b>. С одной стороны — этот глагол произошел от существительного <b>«отладка»</b>, с другой — его значение вполне можно интерпретировать, как <b>«избавление от лажи»</b>. И, поверьте, второе случается гораздо чаще. Особенно, когда вы только начинаете программировать</p>
                <p>Внутри метода мы просто вызываем статический метод <b>initModels</b> нашего класса с предметами</p>
                <p>Казалось бы, все, да? <b>Нет!</b> Дело в том, что на текущий момент, если мы запустим игру, ошибок не будет. Но наш предмет будет иметь имя <b>item.tutorial.key.name</b>, а выглядеть он будет как квадрат с противного цвета текстурой, чем-то напоминающей кусок шахматной доски какого-то извращенца</p>
                <p>Давайте исправлять. Первым пунктом, нам нужно создать структуру каталогов для ресурсов проекта. Сделать это нужно так, чтобы в итоге у нас получилось вот такое вот дерево:</p>
                <div class="derevo p--1" id="derevo">
                    <p>src</p>
                    <p class="p-1"><span class="put"></span>main</p>
                    <p class="p-2"><span class="put"></span>resources</p>
                    <p class="p-3"><span class="put"></span>assets</p>
                    <p class="p-4"><span class="put"></span>tutorial <span>(техническое имя мода)</span></p>
                    <p class="p-5"><span class="put"></span>lang <span>(здесь будут файлы локализации)</span></p>
                    <p class="p-5 p--2"><span class="put"></span>models</p>
                    <p class="p-6"><span class="put"></span>item <span>(здесь хранятся файлы с моделями предметов)</span></p>
                    <p class="p-5 p--3"><span class="put"></span>textures</p>
                    <p class="p-6"><span class="put"></span>items <span>(здесь хранятся текстуры предметов)</span></p>
                </div>
                <p>И начнем создавать файлы прямо по порядку следования каталогов. В <b>IDEA</b> сделаем правый клик на каталоге <b>resources/asstes.tutorial/lang</b> и выберем <b>«New → File»</b>. В качестве имени файла укажем <b>«en_US.lang»</b> (регистр букв важен!). В этом файле мы опишем соответствия внутренним <b>«нелокализованным»</b> именам предметов и блоков и читаемых названий на английском языке</p>
                <p class="warn">Если вам нетерпится перевести свой мод на русский, просто создайте по тому же пути файл с именем «ru_RU.lang» — в него вы будете вписывать перевод на русский. Однако, файл с английским языком все еще необходим</p>
                <p class="info">В <b>IDEA</b> существует плагин, который добавляет поддержку для <b>.lang</b> файлов. Сделан плагин специально для мододелов майнкрафта, и IDEA вам предложит его установить как только вы откроете <b>.lang</b> файл в редакторе. Соглашайтесь, или не соглашайтесь по своему усмотрению</p>
                <p>В открывшемся файле нам надо очень аккуратно прописать перевод названия нашего предмета на английский язык. Делается это следующей строчкой:</p>
                <div class="code">
                    item.tutorial.key.name=Key
                </div>
                <p class="warn">Нелокализованное имя для предмета формируется следующим образом: <b>item. техническое имя мода. регистровое имя предмета. name=.</b> Пробелы после <b>name</b> не допускаются равно как и пробелы после знака равенства!</p>
                <p>Если хотите, в файле <b>ru_RU.lang</b> можете прописать аналогичную строку с переводом названия предмета на русский:</p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/resources/assets.tutorial/lang/en_us" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    item.tutorial.key.name=Ключ
                </div>
                <p>Дальше. В <b>models/items</b> создадим файл с именем <b>«регистровое имя предмета.json»</b>. В нашем случае: <b>key.json</b></p>
                <div class="code">
                    <a href="https://dmitriy-407.github.io/zig/code/2/resources/assets.tutorial/models/item/key" class="open">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="link_24"><g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z"></path><path d="M16.544 9.193L7.096 18.64a1.228 1.228 0 0 1-1.736-1.736l9.447-9.448H8.93A1.228 1.228 0 1 1 8.93 5h8.842C18.45 5 19 5.55 19 6.228v8.842a1.228 1.228 0 1 1-2.456 0V9.193z" class="color" fill-rule="nonzero"></path></g></svg>
                        <span class="text">Исходник</span>
                    </a>
                    {
                      <div>
                          <span class="color--violet">"parent"</span><span class="color--orang">:</span> <span class="color--green">"item/generated"</span><span class="color--orang">,</span><br>
                          <span class="color--violet">"textures"</span><span class="color--orang">:</span> {
                          <div><span class="color--violet">"layer0"</span><span class="color--orang">:</span> <span class="color--green">"tutorial:items/key"</span></div>
                          }
                    </div>
                    }
                </div>
                <p>Это, ребятки, ванильное описание модели предмета. За более подробной информацией, я вас отправлю читать <a href="https://minecraft.gamepedia.com/Model#Item_models">вики по ванилле</a></p>
                <p>А от себя лишь скажу, что в значении <b>«layer0»</b> указывается относительный путь до файла-текстуры предмета без указания расширения. <b>«tutorial:items/key»</b> означает, что наша текстура расположена в src/main/resources/assets/<b>tutorial</b>/textures/<b>items</b>/<b>key.png</b></p>
                <p class="warn">Все текстуры в майнкрафте должны иметь формать <b>PNG</b>, а размер текстур в ванильном майнкрафте всего 16х16 пикселей</p>
                <p>Теперь осталось наваять какую-нибудь текстуру в любимом графическом редакторе, сохранить ее в файл в формате <b>PNG</b>, назвать <b>«key» (со строчной буквы!!!)</b> и поместить в <b>textures/items</b></p>
                <p>Художник из меня, конечно, тот еще, но тем, кому лень рисовать текстуру ключа, вот вам мой вариант:</p>
                <div id="key" class="image--donwload"><p class="image--info" style="background-image: url(https://dmitriy-407.github.io/zig/download/key.png)"></p><a download href="https://dmitriy-407.github.io/zig/download/key.png">Скачать</a></div>
                <p>Теперь пришла пора запустить наш мод! Сверху справа в окне <b>IDEA</b> выбираем конфигурацию <b>«Minecraft Client»</b> и нажимаем на иконку с зеленым жучком!</p>
                <p class="imag" style="background-image: url(https://pp.userapi.com/c858028/v858028799/16c07/xLQrtY5Mqws.jpg); height: 120px;" onclick="image('https://pp.userapi.com/c858028/v858028799/16c07/xLQrtY5Mqws.jpg')"></p>
                <p>У нас должен запуститься клиент майнкрафта. Создаем новый мир, включаем креативный режим, открываем инвентарь и ищем предмет с нашим именем, то-есть <b>«Key»</b>. Если вы все сделали правильно, вы его найдете! И даже увидите, что он выглядит как красный ключ <span style="color: #ccc;">(или вы нарисовали свою текстуру?)</span></p>
                <p class="imag" style="background-image: url(https://sun1-25.userapi.com/c858028/v858028799/16c18/UQuWqtY0lP4.jpg); height: 300px;" onclick="image('https://sun1-25.userapi.com/c858028/v858028799/16c18/UQuWqtY0lP4.jpg')"></p>
                <a href="https://dmitriy-407.github.io/zig/code/2/java/ru.zigthehedge.tutorial/tutorial" class="donwload">Исходники</a>
            </div>
        </div>
        <div class="window"></div>
        <p class="up" onclick="up()"></p>
        <footer>
            <div class="content">
                <p class="avtor">Автор используемых материалов <a href="https://vk.com/zigthehedge">ZigTheHedge</a></p>
                <p class="image">Используются изображения с <a href="https://www.minecraft.net">Minecraft.net</a></p>
                <p class="dev">Разработано <a href="https://vk.com/demon_407">Dmitriy Popov</a></p>
            </div>
        </footer>
        <script src="/zig/script.js" type="text/javascript"></script>
    </body>
</html>