<!DOCTYPE html>
<html>
    <head>
        <link href="https://cwelth.com/gfx/summer-icon.png" rel="icon"/>
        <link href="/zig/font.css" rel="stylesheet" type="text/css"/>
        <link href="/zig/style.css" rel="stylesheet" type="text/css"/>
        <meta property="og:title" content="Урок #3"/>
        <meta property="vk:image"  content="https://dmitry-407.github.io/zig/img/3.png"/>
        <meta charset="utf-8">
        <title>Руководство по моддингу</title>
        <script type="text/javascript" src="https://www.google.com/jsapi"></script>
        <script type="text/javascript">
            google.load("jquery", "1.3.2");
            google.load("jqueryui", "1.7.2");
        </script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
        <div class="content">
            <a href="/zig/">
                <div class="forg">
                <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Ebene_1" x="0px" y="0px" width="100%" height="100%" viewBox="0 0 316 66.7" style="enable-background:new 0 0 316 66.7;" xml:space="preserve">
                    <style type="text/css">
                        .st0{fill:#DFA86A;}
                        .st1{fill:#26303d;}
                    </style>
                    <g>
                        <g>
                            <polygon class="st0" points="114.1,55.6 125,55.6 125,38.7 143,38.7 143,28.4 125,28.4 125,21.4 144.1,21.4 144.1,11.1     114.1,11.1   "/>
                            <path class="st0" d="M185.3,16.3c-2.1-2.1-4.6-3.6-7.5-4.7c-2.7-1-5.8-1.5-9-1.5l-0.4,0c-3.4,0-6.5,0.6-9.3,1.7    c-2.9,1.1-5.4,2.7-7.4,4.8c-2.1,2.1-3.7,4.6-4.9,7.5c-1.2,2.9-1.7,6.1-1.7,9.6c0,3.4,0.6,6.6,1.8,9.4c1.2,2.8,2.8,5.3,4.9,7.3    c2.1,2,4.6,3.6,7.4,4.7c2.8,1.1,6,1.7,9.3,1.7h0h0c3.4,0,6.6-0.6,9.4-1.8c2.9-1.1,5.4-2.8,7.5-4.8c2.1-2,3.7-4.5,4.9-7.4    c1.2-2.8,1.8-6,1.8-9.4c0-3.5-0.6-6.7-1.7-9.6C189,20.9,187.3,18.4,185.3,16.3z M180.6,33.1c0,2-0.3,3.8-0.9,5.4    c-0.6,1.6-1.4,3-2.5,4.2c-1,1.1-2.3,2.1-3.8,2.7c-1.5,0.7-3.2,1-5,1c-1.8,0-3.5-0.3-5-1c-1.5-0.7-2.7-1.6-3.8-2.7    c-1.1-1.2-1.9-2.6-2.5-4.2c-0.6-1.6-0.9-3.5-0.9-5.4c0-1.8,0.3-3.5,0.9-5c0.6-1.5,1.4-2.9,2.5-4c1-1.1,2.3-2,3.8-2.7    c1.5-0.6,3.1-1,5-1c1.8,0,3.5,0.3,5,1c1.5,0.6,2.8,1.5,3.8,2.7c1.1,1.1,1.9,2.5,2.5,4C180.3,29.6,180.6,31.3,180.6,33.1z"/>
                            <path class="st0" d="M224.2,33.3c1.9-2.3,2.9-5.2,2.9-8.6c0-2.6-0.5-4.8-1.5-6.6c-1-1.8-2.4-3.2-4-4.2c-1.6-1-3.4-1.7-5.5-2.1    c-1.9-0.4-4-0.6-6-0.6h-16v44.5h11V38.3h2.3l9.4,17.3h13.1l-11.2-18.6C220.9,36.2,222.8,35,224.2,33.3z M204.9,21h4.4    c0.8,0,1.7,0.1,2.6,0.2c0.8,0.1,1.5,0.3,2.1,0.6c0.5,0.2,0.9,0.6,1.2,1c0.3,0.4,0.4,1,0.4,1.8c0,0.9-0.2,1.6-0.5,2.1    c-0.3,0.5-0.8,0.8-1.3,1c-0.7,0.3-1.5,0.5-2.3,0.6c-1,0.1-2,0.1-2.9,0.1h-3.8V21z"/>
                            <path class="st0" d="M242.7,24c1-1.1,2.3-2,3.8-2.7c1.5-0.6,3.1-1,5-1c1.8,0,3.6,0.3,5.3,0.9c1.6,0.6,3,1.4,4.1,2.5l1.3,1.3l8-8.1    l-1.5-1.3c-2.4-2.1-5.1-3.6-8.1-4.4c-2.9-0.8-6-1.2-9.2-1.2c-3.4,0-6.5,0.6-9.3,1.7c-2.9,1.1-5.4,2.7-7.4,4.8    c-2.1,2.1-3.7,4.6-4.9,7.5c-1.2,2.9-1.7,6.1-1.7,9.6c0,3.4,0.6,6.6,1.8,9.4c1.2,2.8,2.8,5.3,4.9,7.3c2.1,2,4.6,3.6,7.4,4.7    c2.8,1.1,6,1.7,9.3,1.7c6.5,0,12.5-1.4,17.8-4.3l1-0.5V28h-19.3v10.3h8.4V45c-0.9,0.4-1.8,0.7-2.9,0.9c-1.5,0.3-3.1,0.5-4.8,0.5    c-1.8,0-3.5-0.3-5-1c-1.5-0.7-2.7-1.6-3.8-2.7c-1.1-1.2-1.9-2.6-2.5-4.2c-0.6-1.6-0.9-3.5-0.9-5.4c0-1.8,0.3-3.5,0.9-5    C240.9,26.5,241.7,25.1,242.7,24z"/>
                            <polygon class="st0" points="285.6,45.3 285.6,38 304.3,38 304.3,27.7 285.6,27.7 285.6,21.4 305.4,21.4 305.4,11.1 274.6,11.1     274.6,55.6 306.4,55.6 306.4,45.3   "/>
                        </g>
                        <path class="st1" d="M91.6,16.7l-37.8-1.9l46.2,0v-3.7H47.8l0,7.8v6.2c0,0.1-1.5-9.1-1.9-11.7h-4.1v6.8v6.2   c0,0.1-1.8-10.9-1.9-12.3c-10.4,0-27.9,0-27.9,0c1.9,1.6,12.4,10.6,19.9,14.3c3.7,1.8,8.3,1.9,12.4,2c2.1,0.1,4.2,0.2,5.8,1.8   c2.3,2.2,2.8,5.7,0.8,8.3c-1.9,2.6-7.3,3.2-7.3,3.2L39,49.1v6.4h10.3l0.3-6.3l8.9-6.3c-0.9,0.8-3.1,2.8-6.2,7.7   c-0.7,1.1-1.3,2.3-1.7,3.5c2.2-1.9,6.8-3.2,12.2-3.2c5.3,0,9.9,1.3,12.1,3.2c-0.4-1.2-1-2.4-1.7-3.5c-3.2-4.9-5.3-6.9-6.2-7.7   l8.9,6.3l0.3,6.3h9.6v-6.4l-4.5-5.5c0,0-6.7-0.4-8.4-3.2C67.7,32.6,74.8,20.4,91.6,16.7z"/>
                    </g>
                    </svg>
                </div>
                <h1>Руководство по моддингу</h1>
            </a>
            <div class="body--content">
                <div class="lesson-header">
                    <p class="img" style="background-image: url(https://www.minecraft.net/etc.clientlibs/minecraft/clientlibs/main/resources/img/menu/menu-realms.svg)"></p>
                    <h1>Урок #3</h1>
                </div>
                <h4>И здравствуйте, уважаемые</h4>
                <p>С вами ZigTheHedge и в сегодняшней статье мы научимся создавать блоки. Один - чисто строительный и декоративный, один - в виде руды, и еще один — как многие из вас уже догадались по «ключу» из первой статьи — функциональный</p>
                <p>Ну и, конечно же, нас, как разработчиков, в первую очередь будет волновать именно внутреннее устройство блоков, а не их внешний вид. А все потому, что рисовать я не умею, как я уже неоднократно говорил. Ну да ладно. Поехали!</p>
                <p class="warn">Если вы не ознакомились с <a href="/zig/lesson/2">предыдущей статьей</a> — марш читать!</p>
                <p>Как и в случае с предметами, чтобы нам было проще разобраться в структуре нашего мода, создадим под блоки отдельный пакет и назовем его <b>«blocks»</b></p>
                <p>В этом пакете создадим новый класс, который будет описывать наш первый — декоративный блок. Назовем класс <b>BathroomTile</b>. Почему? Потому что я хочу декоративный блок в виде плитки в ванну. Да, вот такой я ленивый — вместо того, чтобы купить плитку в реале, я вам рассказываю, как нарисовать нечто похожее! Класс должен наследовать базовый класс майнкрафта под именем <b>Block</b></p>
                <div class="code">
                    <span class="color--orang">package</span> ru.zigthehedge.tutorial.blocks<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraft.block.Block<span class="color--orang">;</span><br>
                    <br>
                    <span class="color--orang">public class</span> BathroomTile <span class="color--orang">extends</span> Block {<br>
                    }
                </div>
                <p>Наш блок всегда будет выглядеть одинаково. С какой стороны на него не посмотри, какой стороной его не ставь. Просто потому что он декоративный и самый простой вид блока, который только можно создать в майнкрафте</p>
                <p>Как и в случае с предметами, нам нужно создать конструктор класса и прописать в нем необходимые описательные вещи для нашего плиточного блока</p>
                <p>Когда вы опишете класс, который наследует <b>«Block»</b>, <b>IDEA</b> подчеркнет декларацию красным. Поставьте курсор на эту строчку, нажмите <b>Alt+Enter</b> и выберите <b>«Create constructor matching super»</b> <span style="color: #ccc">(что переводится как <b>«создать конструктор, который вызывает конструктор наследованного класса»</b>)</span></p>
                <p class="imag" style="background-image: url(https://pp.userapi.com/c849216/v849216561/1e7682/mM7babmqcDE.jpg); height: 200px;" onclick="image('https://pp.userapi.com/c849216/v849216561/1e7682/mM7babmqcDE.jpg')"></p>
                <p>В открышемся окне с вариантами, выберите нижний:</p>
                <p class="imag" style="background-image: url(https://pp.userapi.com/c849216/v849216561/1e7689/Oo4efa-U_4s.jpg); height: 500px;" onclick="image('https://pp.userapi.com/c849216/v849216561/1e7689/Oo4efa-U_4s.jpg')"></p>
                <p>В принципе, нам без разницы какой выбирать, так как мы все равно все сделаем по-своему, но IDEA надо успокоить. Итак, у нас получилось следующее:</p>
                <div class="code">
                    <span class="color--orang">package</span> ru.zigthehedge.tutorial.blocks<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraft.block.Block<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraft.block.material.Material<span class="color--orang">;</span><br>
                    <br>
                    <span class="color--orang">public class</span> BathroomTile <span class="color--orang">extends</span> Block {<br>
                    <div><span class="color--orang">public</span> <span class="color--orang--2">BathroomTile</span>(Material materialIn) {</div>
                        <div><div><span class="color--orang">super</span>(materialIn)<span class="color--orang">;</span></div></div>
                    <div>}</div>
                    }
                </div>
                <p class="warn">При таком способе создания конструктора, IDEA автоматически добавила нужные <b>import'</b>ы</p>
                <p>Теперь нам надо переделать конструктор под свой лад. Уберем входной параметр <span style="color: #ccc;">(он нам не нужен, у нас свой блок)</span>, и при вызове <b>суперконструктора</b> <span style="color: #ccc;">(ужасное слово!!)</span> просто передадим материал, из которого будет состоять наш блок</p>
                <div class="code">
                    ...<br>
                    <span class="color--orang">public class</span> BathroomTile <span class="color--orang">extends</span> Block {<br>
                    <div><span class="color--orang">public</span> <span class="color--orang--2">BathroomTile</span>() {</div>
                    <div><div><span class="color--orang">super</span>(Material.<span class="color--violet">ROCK</span>)<span class="color--orang">;</span></div></div>
                    <div>}</div>
                    }<br>
                    ...
                </div>
                <p class="info">Материал <span style="color: #ccc;">(статические свойства класса <b>Material</b>)</span> описывают поведение материала, включающее в себя такие его свойства как: прочность, взрывоустойчивость, звук ходьбы, возможность двигать блок поршнем, возможность проходить сквозь блок и т.д. Чтобы увидеть полный набор свойств материала, наведите курсор мышки на <b>«.ROCK»</b> и, зажав <b>Ctrl</b>, кликните левой кнопкой — у вас откроется исходник класса, в котором описано это свойство. Там вы сможете посмотреть, какие именно свойства определяются материалом, а также список всех материалов, определенных ваниллой</p>
                <p>В принципе, разумеется, есть возможность создать свой материал. Но на практике сильно проще выбрать подходящий по параметрам материал из ваниллы, если вы, конечно, не делаете какую-нибудь принципиально новую сущность <span style="color: #ccc;">(например, блок желе, которое будет расползаться со временем, или что-то похожее)</span>, либо же, если вы не создаете жидкость</p>
                <p class="info">Второй вариант конструктора принимает два параметра: материал и <b>«цвет»</b> блока <span style="color: #ccc;">(<b>MapColor</b>)</span>. В принципе, если вы можете определить цвет своего блока из 16 стандартных майнкрафтовских цветов, вы можете воспользоваться им, и указать вторым параметром в вызове суперконструктора этот цвет. Это позволит механике игры знать, к какому цвету относится ваш блок и, например, при помощи <b>JEI </b> Вы будете видеть свой блок при поиске по цвету</p>
                <p>Теперь давайте добавим в конструктор стандартные необходимые параметры блока:</p>
                <div class='code'>
                    ...<br>
                    <span class="color--orang">public</span> <span class="color--orang--2">BathroomTile</span>() {<br>
                        <div><span class="color--orang">super</span>(Material.<span class="color--violet">ROCK</span>);<br>
                        setRegistryName(<span class="color--green">"bathroomtile"</span>)<span class="color--orang">;</span><br>
                        setUnlocalizedName(Tutorial.<span class="color--violet">MODID</span> + <span class="color--green">".bathroomtile"</span>)<span class="color--orang">;</span><br>
                        setCreativeTab(CreativeTabs.<span class="color--violet">BUILDING_BLOCKS</span>)<span class="color--orang">;</span></div>
                    }<br>
                    ...
                </div>
                <p>Все так же, как и в случае с предметом. Задаем регистровое имя, нелокализованное имя и вкладку креативного инвентаря. В этот раз, я использовал вкладку <b>«строительные блоки»</b> <span style="color: #ccc;">(<b>BUILDING_BLOCKS</b>)</span>, потому что почему бы нет?</p>
                <p>В этот раз, давайте добавим еще два свойства. Первое — переопределит прочность нашего блока, второе - скажет, что вскопать этот блок можно только алмазной киркой <span style="color: #ccc;">(или любой другой киркой из модов, которая может копать обсидиан)</span></p>
                <div class="code">
                    ...<br>
                        <div>setCreativeTab(CreativeTabs.<span class="color--violet">BUILDING_BLOCKS</span>)<span class="color--orang">;</span><br>
                        setHardness(<span class="color--blue">.5F</span>)<span class="color--orang">;</span><br>
                            setHarvestLevel(<span class="color--green">"pickaxe"</span><span class="color--orang">,</span> <span class="color--blue">3</span>)<span class="color--orang">;</span></div>
                    }<br>
                    ...
                </div>
                <p>Методом <b>setHardness</b> мы задаем прочность. Параметром метода является число с плавающей точкой <span style="color: #ccc">(<b>float</b>)</span> и значение <b>0.5</b>. Поэкспериментируйте с прочностью своего блока, пока не добьетесь нужного эффекта</p>
                <p>Метод <b>setHarvestLevel</b> определяет тип инструмента, которым нужно воспользоваться, чтобы <b>«собрать»</b> блок, и его <b>«уровень»</b>. Тип инструменту можно задать при его создании, либо воспользоваться одним из стандартных в майнкрафте: <b>«pickaxe»</b> <span style="color: #ccc">(кирка)</span>, <b>«axe»</b> <span style="color: #ccc">(топор)</span>, <b>«shovel»</b> <span style="color: #ccc">(лопата)</span>. А уровень — это уровень кирки <span style="color: #ccc">(не уверен, что будет, если попробовать задать уровень другим инструментам)</span>:<br><br><b>0</b> — деревянный и золотой инструмент<br><b>1</b> — каменный<br><b>2</b> — желеный<br><b>3</b> — алмазный</p>
                <p>Чтож, мы закончили с описанием нашего блока, теперь давайте создадим методы для регистрации его в регистрах. Создадим два метода. Первый — почти не будет отличаться от такого же, какой мы использовали при создании предмета. Этот метод будет описывать текстуру нашего блока, когда он находится в инвентаре:</p>
                <div class="code">
                    ...<br>
                    <span class="color--yellow">@SideOnly</span>(Side.<span class="color--violet">CLIENT</span>)<br>
                    <span class="color--orang">public void</span> <span class="color--orang--2">initModel</span>() {<br>
                        <div>ModelLoader.setCustomModelResourceLocation(Item.getItemFromBlock(<span class="color--orang">this</span>)<span class="color--orang">,</span> <span class="color--blue">0</span><span class="color--orang">,</span> new ModelResourceLocation(getRegistryName(), <span class="color--green">"inventory"</span>));</div>
                    }<br>
                    ...<br>
                </div>
                <p class="warn">В качестве первого аргумента у нас используется вызов статического метода класса <b>Item (Item.getItemFromBlock)</b>, а не сам класс, как это было в случае с предметом</p>
                <p class="info">И вот здесь начинает становиться понятно, почему сначала всегда рассматривается создание предметов. Дело в том, что <b>блок становится блоком</b> только тогда, когда мы его ставим в мир. А пока он в инвентаре, в сундуке, или в <b>JEI</b> — <b>он предмет!</b></p>
                <p>Метод <b>Item.getItemFromBlock</b> как раз и занимается тем, что из класса блока берет привязанный к нему предмет. Правда, нам <b>очень важно</b> не забыть этот самый предмет привязать. Но это немного позже, а теперь — еще один метод. На этот раз метод, который берет модель самого блока, и вытаскивает из нее вариант для предмета, привязанного к этому блоку</p>
                <div class="code">
                    ...<br>
                    <span class="color--yellow">@SideOnly</span>(Side.<span class="color--violet">CLIENT</span>)<br>
                    <span class="color--orang">public void</span> <span class="color--orang--2">initModel</span>() {<br>
                        <div>ModelLoader.setCustomModelResourceLocation(Item.getItemFromBlock(<span class="color--orang">this</span>)<span class="color--orang">,</span> <span class="color--blue">0</span><span class="color--orang">,</span> new ModelResourceLocation(getRegistryName(), <span class="color--green">"inventory"</span>));<br>
                        Minecraft.getMinecraft().getRenderItem().getItemModelMesher().register(itemBlock<span class="color--orang">,</span> 0<span class="color--orang">,</span> itemModelResourceLocation)<span class="color--orang">;</span></div>
                    }<br>
                    ...
                </div>
                <div class="info">
                    <p>Давайте разберем метод построчно</p>
                    <p>Мы создаем локальную переменную типа <b>Item</b> и помещаем в нее объект из регистра предметов, у которого есть модель, расположенная в ресурсах мода, и соответствует регистровому имени <b>«bathroomtile»</b></p>
                    <p>Далее, мы создаем новую переменную, в которую загружаем модель блока соответствующую варианту <b>«inventory»</b> из файла, описывающего состояния блока. Не пугайтесь, мы рассмотрим состояния блока <span style="color: #ccc;">(блокстейты, <b>blockstates</b>)</span> очень скоро</p>
                    <p>И, наконец, мы регистрируем тип рендера для нашего блока в виде предмета в майнкрафте, обращаясь через внутренности майнкрафта к методу, который занимается рендером моделей предметов, и вызывая метод register, в котором указываем для какого предмета <span style="color: #ccc;">(<b>itemBlock</b>)</span> для какого варианта <span style="color: #ccc;">(метаданные, метадата, <b>meta</b>)</span> предмета <span style="color: #ccc;">(<b>0</b>)</span> какую модель выбирать <span style="color: #ccc;">(<b>itemModelResourceLocation</b>)</span>.</p>
                    <p>Сложно? Да, согласен. Именно поэтому я в самом начале сказал, что проект мода относится к <b>«сложным»</b> проектам</p>
                </div>
                <p>Но на этом мы, наконец, закончили с описанием блока в классе. Теперь его надо создать и зарегистрировать. Сначала, как и в случае с предметами, давайте создадим отдельный класс, который будет хранить все наши созданные экземпляры блоков. Класс создаем в том же пакете и назовем, по аналогии с предметным классом, <b>TutorialBlocks</b></p>
                <div class="code">
                    <span class="color--orang">package</span> ru.zigthehedge.tutorial.blocks<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraftforge.fml.common.registry.GameRegistry<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> ru.zigthehedge.tutorial.Tutorial<span class="color--orang">;</span><br>
                    <br>
                    <span class="color--orang">public class</span> TutorialBlocks {<br>
                        <div><span class="color--yellow">@</span>GameRegistry<span class="color--yellow">.ObjectHolder</span>(Tutorial.<span class="color--violet">MODID</span> + <span class="color--green">":bathroomtile"</span>)<br>
                        <span class="color--orang">public static</span> BathroomTile <span class="color--violet">bathroomTile</span><span class="color--orang">;</span></div>
                    }
                </div>
                <p>В классе сразу же создадим аннотацию на экземпляр блока с регистровым именем <b>«bathroomtile»</b> и создадим переменную с указателем на экземпляр блока</p>
                <p>Дальше, создадим наши методы по регистрации текстур и моделей для блоков:</p>
                <div class="code">
                    ...<br>
                    <span class="color--orang">public static</span> BathroomTile <span class="color--violet">bathroomTile</span><span class="color--orang">;</span><br>
                    <br>
                    <span class="color--yellow">@SideOnly</span>(Side.<span class="color--violet">CLIENT</span>)<br>
                    <span class="color--orang">public static void</span> <span class="color--orang--2">initModels</span>() {<br>
                    }<br>
                    <br>
                    <span class="color--yellow">@SideOnly</span>(Side.<span class="color--violet">CLIENT</span>)<br>
                    <span class="color--orang">public static void</span> <span class="color--orang--2">initBlockItemModels</span>() {<br>
                    }<br>
                    ...
                </div>
                <p>Первый метод будет задавать модель для блока, второй — для блока в виде предмета</p>
                <p>В этих методах вызовем методы регистрации моделей для каждого экземпляра блока, которые мы создаем.</p>
                <div class="code">
                    ...<br>
                    <span class="color--orang">public static</span> BathroomTile <span class="color--violet">bathroomTile</span><span class="color--orang">;</span><br>
                    <br>
                    <span class="color--yellow">@SideOnly</span>(Side.<span class="color--violet">CLIENT</span>)<br>
                    <span class="color--orang">public static void</span> <span class="color--orang--2">initModels</span>() {<br>
                        <div><span class="color--violet">bathroomTile</span>.initModel();</div>
                    }<br>
                    <br>
                    <span class="color--yellow">@SideOnly</span>(Side.<span class="color--violet">CLIENT</span>)<br>
                    <span class="color--orang">public static void</span> <span class="color--orang--2">initBlockItemModels</span>() {<br>
                        <div><span class="color--violet">bathroomTile</span>.initItemModel();</div>
                    }<br>
                    ...
                </div>
                <p>Блок у нас пока что один, поэтому и вызываем регистрации только для него</p>
                <p>Дальше, опять же, как и в случае с предметом, нам надо добавить ссылку на наш блок в регистр. Открываем наш <b>CommonProxy</b> и добавляем в него метод, который будет обрабатывать событие <b>«регистрация объекта — блок»</b>:</p>
                <div class="code">
                    ...<br>
                    <span class="color--yellow">@SubscribeEvent</span><br>
                    <span class="color--orang">public static void</span> registerBlocks(RegistryEvent.Register&lt;Block&gt; event) {<br>
                    }<br>
                    ...
                </div>
                <p>Я назвал метод <b>registerBlocks</b>, чтобы не забыть, что делает этот метод. Входящий параметр метода — <b>RegistryEvent.Register&lt;Block&gt;</b>. Внутри нашего обработчика давайте зарегистрируем наш новый блок:</p>
                <div class="code">
                    ...<br>
                    <span class="color--yellow">@SubscribeEvent</span><br>
                    <span class="color--orang">public static void</span> registerBlocks(RegistryEvent.Register&lt;Block&gt; event) {<br>
                        <div>event.getRegistry().register(<span class="color--orang">new</span> BathroomTile())<span class="color--orang">;</span></div>
                    }<br>
                    ...
                </div>
                <p>Пока все аналогично предмету</p>
                <p>Осталось в <b>ClientProxy</b> добавить вызов регистрации моделей нашего блока. Сделаем это в методе <b>registerModels</b>, где у нас уже регистрируются модели предметов:</p>
                <div class="code">
                    ...<br>
                    <span class="color--yellow">@SubscribeEvent</span><br>
                    <span class="color--orang">public static void</span> registerModels(ModelRegistryEvent event) {<br>
                        <div>TutorialItems.initModels()<span class="color--orang">;</span><br>
                        TutorialBlocks.initModels()<span class="color--orang">;</span></div>
                    }<br>
                    ...
                </div>
                <p><b>А вот теперь самое важное, о чем нельзя было забыть</b>: мы зарегистрировали блок, но! Нам надо так же зарегистрировать <b>предмет блока</b> отдельно! <b>Forge</b> за нас это, к сожалению, не сделает. Поэтому, возвращаемся в <b>CommonProxy</b> и в методе <b>registerItems</b> дописываем регистрацию предмета нашего блока:</p>
                <div class="code">
                    ...<br>
                    <span class="color--yellow">@SubscribeEvent</span><br>
                    <span class="color--orang">public static void</span> registerItems(RegistryEvent.Register&lt;Item&gt; event) {<br>
                        <div>event.getRegistry().register(<span class="color--orang">new</span> Key())<span class="color--orang">;</span><br>
                        <br>
                        event.getRegistry().register(<span class="color--orang">new</span> ItemBlock(TutorialBlocks.bathroomTile).setRegistryName(TutorialBlocks.bathroomTile.getRegistryName()))<span class="color--orang">;</span></div>
                    }<br>
                    ...
                </div>
                <p class="warn">Я специально оставил пробел между регистрацией предметов и блоков предметов — так будет удобнее <span style="color: #ccc;">(ну, лично мне)</span>. Что мы делаем этим методом?</p>
                <p>Мы создаем экземпляр <b>ItemBlock</b>'а <span style="color: #ccc;">(это стандартный класс майнкрафта, который описывает стандартные предметы блоков и нам достаточно его базового варианта, чтобы зарегистрировать простой предмет для нашего блока)</span>. В качестве входного параметра конструктор <b>ItemBlock</b>'а берет класс типа <b>Block</b> <span style="color: #ccc;">(или его производные)</span>. Дальше, для этого предмета надо установить регистровое имя. В качестве регистрового имени, мы берем то же имя, которое имеет наш блок</p>
                <p>Мы зарегистрировали и блок и предмет блока. Однако, мы не сделали еще одну важную вещь — мы не зарегистрировали модель предмета блока. Возвращаемся в <b>ClientProxy</b></p>
                <div class="code">
                    ...<br>
                    <span class="color--yellow">@Override</span><br>
                    <span class="color--orang">public void</span> postInit(FMLPostInitializationEvent e) {<br>
                        <div>TutorialBlocks.initBlockItemModels()<span class="color--orang">;</span><br>
                        <span class="color--orang">super</span>.postInit(e)<span class="color--orang">;</span></div>
                    }<br>
                    ...
                </div>
                <p>В методе, который отвечает за событие пост-инициализации, добавим вызов регистрации модели предмета блока, просто вызвав соответствующий статический метод из нашего <b>TutorialBlocks</b></p>
                <p>Фух. Выдыхаем. Мы почти закончили. Давайте добавим локализацию названия нашего блока в <b>en_US.lang</b>. Для блоков конструкция имеет следующий формат: <b>tile</b>.техническое_название_мода.регистровое_имя_предмета.<b>name</b>= Локализованное имя. <b>Не забываем, что пробелы перед и после знака равенства недопустимы!</b></p>
                <div class="code">
                    ...<br>
                    tile.tutorial.bathroomtile.name=Bathroom Tile
                </div>
                <p>А теперь еще одно отличие блоков от предметов. После этого шага мы, при создании предмета, создали ему модель и текстуру и разместили соответствующие файлы в соответствующие каталоги в <b>«ресурсах»</b> проекта. Те же шаги нужно предпринять и для блока, но есть еще один — первый. Каждый блок в майнкрафте имеет <b>«состояния»</b> или <b>blockstates</b>. Состояния описывают текущее, ну, состояние блока. Например, в какую сторону блок повернут, включен он или выключен, сломан он или нет, а так же варианты блока (например, в ванилле гладкий камень, гранит, андезит и диорит — это все один и тот же блок, просто в разных состояниях). Эти состояния должны быть описаны для всех без исключения блоков, даже если у блока всего одно единственное состояние. Описываются они в файле, названном <b>регистровое_имя_блока.json</b>, и помещенном в <b>resources/assets/mod_id/blockstates</b>. Этот каталог мы еще не создавали, поэтому пришло самое время</p>
                <div class="derevo p--1">
                    <p>src</p>
                    <p class="p-1"><span class="put"></span>main</p>
                    <p class="p-2"><span class="put"></span>resources</p>
                    <p class="p-3"><span class="put"></span>assets</p>
                    <p class="p-4"><span class="put"></span>tutorial <span>(техническое имя мода)</span></p>
                    <p class="p-5"><span class="put"></span>blockstates <span>(здесь будут файлы состояний блоков)</span></p>
                    <p class="p-5 p--2"><span class="put"></span>models</p>
                    <p class="p-6"><span class="put"></span>block <span>(здесь хранятся файлы с моделями блоков)</span></p>
                    <p class="p-5 p--3"><span class="put"></span>textures</p>
                    <p class="p-6"><span class="put"></span>blocks <span>(здесь хранятся текстуры блоков)</span></p>
                </div>
                <p>Помимо <b>«blockstates»</b> создадим сразу и каталоги под модели и текстуры</p>
                <p>Теперь давайте создадим файл <b>bathroomtile.json</b> в <b>blockstates</b> и напишем в нем кошмарики:</p>
                <div class="code">
                    {<br>
                        <div><span class="color--violet">"forge_marker"</span><span class="color--orang">:</span> <span class="color--blue">1</span><span class="color--orang">,</span><br>
                        <span class="color--violet">"defaults"</span><span class="color--orang">:</span> {<br>
                        <div><span class="color--violet">"model"</span><span class="color--orang">:</span> <span class="color--green">"tutorial:bathroomtile"</span></div>
                      }<span class="color--orang">,</span><br>
                      <span class="color--violet">"variants"</span><span class="color--orang">:</span> {<br>
                        <div>
                            <span class="color--violet">"normal"</span><span class="color--orang">:</span> [{}]<span class="color--orang">,</span><br>
                            <span class="color--violet">"inventory"</span><span class="color--orang">:</span> [{<br>
                                <div><span class="color--violet">"transform"</span><span class="color--orang">:</span> <span class="color--green">"forge:default-block"</span></div>
                            }]
                        </div>
                      }</div>
                    }
                </div>
                <p>Кошмарики представляют собой ванильный <b>blockstate</b>-файл. И его описание можно найти на <a href="https://minecraft.gamepedia.com/Model">вики майнкрафта</a></p>
                <div class="info">
                    <p>Я же просто скажу, что здесь нам важны несколько вещей:</p>
                    <p>Секция <b>«defaults»</b> описывает значения параметров по-умолчанию. То-есть, если мы с вами в каком-либо варианте не указываем какой-либо параметр, он будет браться из этой секции. Мы описываем здесь нашу модель. Точнее, параметр <b>«model»</b>, который указывает на файл модели. Расположение модели указывается так же, как и в случае с предметом, однако, модели будут искаться в <b>«block»</b>, а не <b>«item»</b>, что весьма контекстно-зависимо</p>
                    <p>Ниже идет блок <b>«variants»</b>, который как раз и описывает варианты <span style="color: #ccc;">(свойства)</span> нашего блока. Здесь как минимум, должны присутствовать два варианта: <b>«normal»</b> — вариант <b>«по-умолчанию»</b> и <b>«inventory»</b> — вариант в инвентаре. Пустые секции допустимы. Так что, в нашем случае, вариант <b>«normal»</b> просто использует все заданные в <b>«defaults»</b> параметры, а вариант <b>«inventory»</b> — все из <b>«defaults»</b> плюс параметр <b>«transform»</b>, который определяет трансформацию объекта. В нашем случае — блок трансформируется стандартным ванильным способом <span style="color: #ccc;">(называемым <b>forge:default-block</b>)</span>, и будет выглядеть, как остальные блоки.</p>
                </div>
                <p>С <b>blockstate</b>-ом разобрались. Теперь — модель. В <b>models/block</b> создаем <b>bathroomtile.json</b> <span style="color: #ccc;">(именно так мы назвали модель в блокстейте)</span> и пишем туда:</p>
                <div class="code">
                    {<br>
                    <div><span class="color--violet">"parent"</span><span class="color--orang">:</span> <span class="color--green">"block/cube_all"</span><span class="color--orang">,</span><br>
                    <span class="color--violet">"textures"</span><span class="color--orang">:</span> {<br>
                        <div><span class="color--violet">"all"</span><span class="color--orang">:</span> <span class="color--green">"tutorial:blocks/bathroomtile"</span></div>
                      }</div>
                    }
                </div>
                <p>Здесь мы указываем, что за основу берется ванильная модель, представляющая собой кубик со всеми одинаковыми текстурами. Расположена эта модель в ванилле по пути <b>assets/minecraft/models/block/cube_all.json</b> Если интересно, можете найти и открыть эту модель, чтобы посмотреть, из чего она состоит</p>
                <p>Если посмотрели, то знаете, что модель является производной от <b>«cube»</b>, и текстуры всех граней указывают на <b>«all»</b>. Именно для этого имени, мы м зададим текстуру в блоке <b>«textures»</b>. Ссылаться эта текстура будет на картинку в формате <b>«png»</b> по пути <b>assets/tutorial/textures/blocks</b>. Создадим текстуру в любимом графическом редакторе и поместим ее по этому пути, назвав файл <b>bathroomtile.png</b></p>
                <div id="bathroomtile" class="image--donwload"><p class="image--info" style="background-image: url(https://dmitry-407.github.io/zig/download/bathroomtile.png)"></p><a download href="https://dmitry-407.github.io/zig/download/bathroomtile.png">Скачать</a></div>
                <p>Теперь мы готовы к тестовому запуску!</p>
                <p class="imag" style="background-image: url(https://pp.userapi.com/c851432/v851432037/16b2e8/g_wP_iR1VK4.jpg); height: 300px;" onclick="image('https://pp.userapi.com/c851432/v851432037/16b2e8/g_wP_iR1VK4.jpg')"></p>
                <p>Урааа! Наш первый блок готов! Теперь, по образу и подобию нашей «плитки в ванну» создадим руду! Назовем ее <b>Redonite</b>. Почему редонит? Потому что с какого-то перепуга, я сделал текстуру ключа красной ) А эта наша руда будет нужна как раз для того, чтобы скрафтить ключ</p>
                <p>Давайте я не буду расписывать каждый шаг, так как вы уже самостоятельно должны понять, как, что, где и куда пихать, чтобы получился блок. Я лишь напомню последовательность:</p>
                <p><span class="number">1</span>Создаем класс в <b>blocks</b>. Класс должен наследовать <b>Block</b>. Называем класс <b>RedoniteOre</b></p>
                <p><span class="number">2</span>В классе создаем конструктор, в котором определяем материал блока <span style="color: #ccc;">(опять-таки, нам подойдет <b>Material.ROCK</b>)</span>, регистровое имя, устанавливаем прочность и выбираем инструмент и уровень добычи</p>
                <p><span class="number">3</span>Создаем в классе два метода для регистрации модели блока и модели предмета блока</p>
                <p><span class="number">4</span>В <b>TutorialBlocks</b> создаем экземпляр блока, аннотируем его <b>@GameObject</b>'ом</p>
                <p><span class="number">5</span>Там же в методах по регистрации моделей, вызываем соответствующие методы нового блока</p>
                <p><span class="number">6</span>В CommonProxy в обработчиках событий по регистрации моделей и блоков, регистрируем наш блок и его предмет</p>
                <p><span class="number">7</span>Создаем <b>blockstate</b> для блока</p>
                <p><span class="number">8</span>Создаем модель для блока</p>
                <p><span class="number">9</span>Добавляем строку локализации в <b>en_US.lang</b></p>
                <p><span class="number">10</span>Рисуем текстуру для блока и помещаем ее по соответствующему пути</p>
                <div id="redonite" class="image--donwload"><p class="image--info" style="background-image: url(https://dmitry-407.github.io/zig/download/redoniteore.png)"></p><a download href="https://dmitry-407.github.io/zig/download/redoniteore.png">Скачать</a></div>
                <p>Если вы все сделали верно, у вас игре появится еще один блок, который, по моей задумке, должен олицетворять руду. Конечно, он пока доступен только через креативный инвентарь, но — все по порядку…</p>
                <p class="imag" style="background-image: url(https://pp.userapi.com/c851432/v851432638/1711e6/gaP7ywsHcdo.jpg); height: 300px;" onclick="image('https://pp.userapi.com/c851432/v851432638/1711e6/gaP7ywsHcdo.jpg')"></p>
                <p class="warn">Я сначала думал в этой статье описать, каким образом сделать так, чтобы наша руда генерировалась в мире, но потом подумал, что мы это рассмотрим в следующей статье вместе с рецептами. А эту статью закончим на добавлении блока, который будет поворачиваться к игроку «лицевой стороной» при установке его в мир</p>
                <p>Итак, наш третий блок!</p>
                <p>Начнем с создания его класса, аналогично двум предыдущим блокам. Я назову блок <b>KeyHole</b>:</p>
                <div class="code">
                    <span class="color--orang">package</span> ru.zigthehedge.tutorial.blocks<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraft.block.Block<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span>net.minecraft.block.material.Material<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraft.client.Minecraft<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraft.client.renderer.block.model.ModelResourceLocation<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraft.creativetab.CreativeTabs<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraft.item.Item<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraft.util.ResourceLocation<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraftforge.client.model.ModelLoader<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraftforge.fml.relauncher.Side<span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> net.minecraftforge.fml.relauncher.<span class="color--yellow">SideOnly</span><span class="color--orang">;</span><br>
                    <span class="color--orang">import</span> ru.zigthehedge.tutorial.Tutorial<span class="color--orang">;</span><br>
                    <br>
                    <span class="color--orang">public class</span> KeyHole <span class="color--orang">extends</span> Block {<br>
                    <div>
                        <span class="color--orang">public</span> <span class="color--orang--2">KeyHole</span>(){<br>
                            <div><span class="color--orang">super</span>(Material.<span class="color--violet">ROCK</span>)<span class="color--orang">;</span><br>
                            setRegistryName(<span class="color--green">"keyhole"</span>)<span class="color--orang">;</span><br>
                            setUnlocalizedName(Tutorial.<span class="color--violet">MODID</span> + ".keyhole")<span class="color--orang">;</span><br>
                            setHardness(<span class="color--blue">.5F</span>)<span class="color--orang">;</span><br>
                            setHarvestLevel(<span class="color--green">"pickaxe"</span>, <span class="color--blue">2</span>)<span class="color--orang">;</span><br>
                            setCreativeTab(CreativeTabs.<span class="color--violet">BUILDING_BLOCKS</span>)<span class="color--orang">;</span></div>
                        }<br>
                        <br>
                        <span class="color--yellow">@SideOnly</span>(Side.<span class="color--violet">CLIENT</span>)<br>
                        <span class="color--orang">public void</span> <span class="color--orang--2">initModel</span>() {<br>
                        <div>ModelLoader.setCustomModelResourceLocation(Item.getItemFromBlock(<span class="color--orang">this</span>)<span class="color--orang">,</span> 0<span class="color--orang">,</span> <span class="color--orang">new</span> ModelResourceLocation(getRegistryName()<span class="color--orang">,</span> "inventory"))<span class="color--orang">;</span></div>
                        }<br>
                        <br>
                        <span class="color--yellow">@SideOnly</span>(Side.<span class="color--violet">CLIENT</span>)<br>
                        <span class="color--orang">public void</span> <span class="color--orang--2">initItemModel</span>() {<br>
                        <div>Item itemBlock = Item.<span class="color--violet">REGISTRY</span>.getObject(<span class="color--orang">new</span> ResourceLocation(Tutorial.<span class="color--violet">MODID</span><span class="color--orang">,</span> <span class="color--green">"keyhole"</span>))<span class="color--orang">;</span><br>
                            ModelResourceLocation itemModelResourceLocation = <span class="color--orang">new</span> ModelResourceLocation(getRegistryName()<span class="color--orang">,</span> <span class="color--green">"inventory"</span>)<span class="color--orang">;</span><br>
                            Minecraft.getMinecraft().getRenderItem().getItemModelMesher().register(itemBlock<span class="color--orang">,</span> <span class="color--blue">0</span><span class="color--orang">,</span> itemModelResourceLocation)<span class="color--orang">;</span></div>
                        }
                    </div>
                    }
                </div>
                <p>Теперь нам надо добавить к блоку свойство <span style="color: #ccc;">(<b>property</b>)</span>, которое будет определять, какой стороной повернут блок. Делается это следующим образом: создаем переменную свойства с названием <b>FACING</b>. Где-нибудь в начале класса:</p>
                <div class="code">
                    ...<br>
                    <span class="color--orang">public class</span> KeyHole <span class="color--orang">extends</span> Block {<br>
                        <br>
                        <div><span class="color--orang">public static</span> PropertyDirection <span class="color--violet">FACING</span> = PropertyDirection.create(<span class="color--green">"facing"</span>, EnumFacing.Plane.<span class="color--violet">HORIZONTAL</span>)<span class="color--orang">;</span><br>
                        <br>
                        <span class="color--orang">public</span> <span class="color--orang--2">KeyHole</span>(){</div>
                    ...
                </div>
                <p>Тип нашего свойства — <b>PropertyDirection</b> — это встроенный в майнкрафт класс, который определяет <b>«поворот»</b> блока и может принимать значения из перечисления <b>EnumFacing</b> <span style="color: #ccc;">(<b>UP</b>, <b>DOWN</b>, <b>NORTH</b>, <b>SOUTH</b>, <b>EAST</b>, <b>WEST</b>)</span>, однако, в конструкторе мы задаем фильтр. Этот фильтр позволяет поворачивать блок только по горизонтали. То-есть, список значений сокращается до <b>NORTH</b>, <b>SOUTH</b>, <b>EAST</b>, <b>WEST</b>. В конструкторе свойства мы задаем имя нашего свойства — <b>«facing»</b></p>
                <p>Конструктор вызывается неявно. Мы не можем создать переменную этого типа, используя <b>new PropertyDirection()</b>, из-за особенностей реализации этого класса. Поэтому, вместо <b>new</b> мы используем вызов статического метода <b>create</b>, определенного в классе как раз для его создания</p>
                <p class="error">В версиях майнкрафта до <b>1.7.10</b> включительно, вместо свойств использовались метаданные <span style="color: #ccc;">(<b>meta</b>)</span>. Однако, уже в <b>1.13</b>, от меты отказались вообще, заменив ее на свойства полностью. Однако, мы с вами пишем под <b>1.12.2</b> и здесь нам необходимо описывать свойства при помощи <b>Property</b>, а движок игры все еще основывается на <b>метаданных</b>. Поэтому, далее нам <b>необходимо предусмотреть</b> конвертацию свойств в метаданные и наоборот. Если мы этого не сделаем, при сохранении и загрузке мира, все наши свойства пойдут <b>«под нож»</b> и инициализируются значениями по-умолчанию</p>
                <p>Давайте перегрузим два метода, которые как раз отвечают за эту конвертацию:</p>
                <div class="code">
                    ...<br>
                    <span class="color--yellow">@Override</span><br>
                    <span class="color--orang">public int</span> <span class="color--orang--2">getMetaFromState</span>(IBlockState state) {<br>
                        <div><span class="color--orang">return</span> state.getValue(<span class="color--violet">FACING</span>).ordinal()<span class="color--orang">;</span></div>
                    }<br>
                    <br>
                    <span class="color--yellow">@Override</span><br>
                    <span class="color--orang">public</span> IBlockState <span class="color--orang--2">getStateFromMeta</span>(<span class="color--orang">int</span> meta) {<br>
                        <div><span class="color--orang">return</span> <span class="color--orang">this</span>.getDefaultState().withProperty(<span class="color--violet">FACING</span><span class="color--orang">,</span> EnumFacing.getHorizontal(meta))<span class="color--orang">;</span></div>
                    }<br>
                    ...
                </div>
                <div class="info">
                    <p>Первый метод, как видно из названия, возвращает метаданные в зависимости от состояния свойств блока. Текущее состояние передается входным параметром <b>state</b>. Из этого параметра мы, при помощи метода <b>getValue()</b> запрашиваем конкретное свойство. В нашем случае, для блока определено лишь одно свойство, и определено оно переменной <b>FACING</b>, которую мы создали ранее. Дальше, учитывая, что данная переменная ссылается на значение из перечисления <b>EnumFacing</b>, мы просто возьмем индекс текущего значения. Делается это методом <b>ordinal()</b></p>
                    <p>Второй метод преобразует полученную мету в состояние. Здесь мы берем состояние нашего блока «по-умолчанию» методом <b>getDefaultState()</b> и заменяем ему свойство,<b>FACING</b> на значение из перечисления <b>EnumFacing</b> по индексу <b>meta</b>. Помогает нам метод <b>withProperty()</b>, а выбрать значение по индексу — специальный метод <b>getHorizontal()</b></p>
                    <p class="warn">Перечисление <b>EnumFacing</b> начинается с <b>DOWN</b>, затем идет <b>UP</b>, и только потом идут необходимые нам определения. Если бы мы создавали перечисление самостоятельно, то вместо <b>getHorizontal()</b> мы бы могли воспользоваться стандартным механизмом получения значения перечисления по индексу при помощи <b>Enum.values()[meta]</b>, но если мы попробуем провернуть такое для <b>EnumFacing</b>, который создан с использованием фильтра <b>Plane.HORIZONTAL</b>, мы получим краш с ошибкой, что нельзя установить значение свойства блока в <b>«DOWN»</b></p>
                </div>
                <p>Кстати, нам нужно сделать еще одну важную вещь прежде, чем мы перейдем с заданию свойства. Нам нужно как раз задать этот самый default state! Иначе там будет неопределенное значение, и как наш блок поведет себя в игре — неясно. Вернемся в конструктор нашего блока и добавим туда строчку:</p>
                <div class="code">
                    ...<br>
                        <div>setDefaultState(<span class="color--violet">blockState</span>.getBaseState().withProperty(<span class="color--violet">FACING</span><span class="color--orang">,</span> EnumFacing.<span class="color--violet">NORTH</span>))<span class="color--orang">;</span></div>
                    }<br>
                    ...
                </div>
                <p>Таким образом мы взяли базовое состояние <span style="color: #ccc;">(оно одинаково для всех блоков в игре)</span>, и добавили в него наше свойство <b>FACING</b>, с указанием на север. В принципе, нам без разницы, куда будет указывать наше состояние по-умолчанию, но пусть оно это делает всегда в одном и том же направлении.</p>
                <p>Теперь нам нужно создать хранилище для наших свойств. Делается это перегрузкой метода <b>createBlockState</b>:</p>
                <div class="code">
                    ...<br>
                    <span class="color--yellow">@Override</span><br>
                    <span class="color--orang">protected</span> BlockStateContainer <span class="color--orang--2">createBlockState</span>() {<br>
                        <div><span class="color--orang">return new</span> BlockStateContainer(<span class="color--orang">this</span><span class="color--orang">,</span> <span class="color--violet">FACING</span>)<span class="color--orang">;</span></div>
                    }<br>
                    ...<br>
                </div>
                <p>В теле метода вы создаем и возвращаем контейнер для данного блока <span style="color: #ccc;">(<b>this</b>)</span>, содержащий место для свойства <b>FACING</b></p>
                <p>Чтож, теперь надо это свойство задавать. Когда это лучше делать? Тогда, когда блок ставится игроком в мир! Для этого есть даже отдельный метод в базовом классе блока:</p>
                <div class="code">
                    ...<br>
                    <span class="color--yellow">@Override</span><br>
                    <span class="color--orang">public void</span> <span class="color--orang--2">onBlockPlacedBy</span>(World worldIn<span class="color--orang">,</span> BlockPos pos<span class="color--orang">,</span> IBlockState state<span class="color--orang">,</span> EntityLivingBase placer<span class="color--orang">,</span> ItemStack stack) {<br>
                        <div>worldIn.setBlockState(pos, state.withProperty(<span class="color--violet">FACING</span><span class="color--orang">,</span> placer.getHorizontalFacing().getOpposite())<span class="color--orang">,</span> <span class="color--blue">2</span>)<span class="color--orang">;</span></div>
                    }<br>
                    ...
                </div>
                <p>Метод <b>onBlockPlacedBy</b> вызывается сразу после того, как блок поставлен в мир. В этот момент блок только появился в мире и еще не отрисовался игроку. Поэтому, это отличное время для того, чтобы установить его состояние. Состояние в мире устанавливается методом <b>setBlockState</b> из экземпляра класса мира, который передается в метод, и ссылается на тот мир, где был установлен блок. <b>World</b> в майнкрафте — это одна из абстракций измерения, так что если вы поставили блок в незере, <b>worldIn</b> будет ссылаться на незер, если в овере — на овер и т.д.</p>
                <p>При вызове <b>setBlockState</b> мы указываем позицию, где нужно установить состояние блока, собственно, само состояние <span style="color: #ccc;">(которое формируем путем определения направления взгляда игрока и взятия противоположной стороны)</span>, и флаг. Флаг определяет, какие события должны быть сгенерированы, когда мы меняем состояние блока. Например, флаг <b>2</b> означает, что нужно оповестить соседние блоки, что у них появился сосед <span style="color: #ccc;">(сделать <b>блок-апдейт</b>, если кто-то слышал этот термин)</span></p>
                <p>На этом мы закончили описание состояния блока. Дальше не забудем создать его экземпляр в <b>TutorialBlocks</b> и зарегистрировать в регистрах, как мы это делали с двумя остальными блоками. И вот теперь нам надо создать его <b>blockstate</b>-файл. Называем его, как обычно, именем регистра <span>(<b>keyhole.json</b>)</span>:</p>
                <div class="code">
                    {<br>
                    <div>
                      <span class="color--violet">"forge_marker"</span><span class="color--orang">:</span> 1<span class="color--orang">,</span><br>
                      <span class="color--violet">"defaults"</span><span class="color--orang">:</span> {<br>
                        <div><span class="color--violet">"model"</span>: <span class="color--green">"tutorial:keyhole"</span></div>
                      }<span class="color--orang">,</span><br>
                      <span class="color--violet">"variants"</span><span class="color--orang">:</span> {<br>
                        <div>
                        <span class="color--violet">"normal"</span><span class="color--orang">:</span> [{}]<span class="color--orang">,</span><br>
                            <span class="color--violet">"inventory"</span><span class="color--orang">:</span> [{<br>
                        <div><span class="color--violet">"transform"</span>: <span class="color--green">"forge:default-block"</span></div>
                        }]<span class="color--orang">,</span><br>
                        <span class="color--violet">"facing"</span><span class="color--orang">:</span> {<br>
                        <div><span class="color--violet">"north"</span><span class="color--orang">:</span> {}<span class="color--orang">,</span><br>
                          <span class="color--violet">"south"</span>: {<span class="color--violet">"y"</span><span class="color--orang">:</span> <span class="color--blue">180</span>}<span class="color--orang">,</span><br>
                          <span class="color--violet">"west"</span>: {<span class="color--violet">"y"</span><span class="color--orang">:</span> <span class="color--blue">270</span>}<span class="color--orang">,</span><br>
                          <span class="color--violet">"east"</span>: {<span class="color--violet">"y"</span><span class="color--orang">:</span> <span class="color--blue">90</span>}</div>
                        }
                        </div>
                      }
                    </div>
                    }
                </div>
                <p class="info">В нашем <b>blockstate-файле</b> появился еще один вариант. Называется он ровно так, как мы это указали в конструкторе нашего свойства — то-есть, <b>«facing»</b>. Внутри описания этого варианта, мы перечисляем <b>все возможные</b> его состояния. Даже те, которые в итоге имеют пустые свойства. Это необходимо, чтобы наш блок в принципе работал и имел текстуру, потому что при загрузке мода, майнкрафт опросит <b>blockstate</b>-файл <b>на все возможные варианты</b> и закеширует результат. Если он не найдет хотя бы один вариант — блок будет помечен как <b>«ошибочный»</b> и мы снова получим шахматную доску извращенцев вместо нашего блока</p>
                <p>Теперь файл с описанием модели:</p>
                <div class="code">
                    {<br>
                    <div>
                      <span class="color--violet">"parent"</span><span class="color--orang">:</span> "block/cube"<span class="color--orang">,</span><br>
                      <span class="color--violet">"textures"</span><span class="color--orang">:</span> {<br>
                        <div><span class="color--violet">"particle"</span>: <span class="color--green">"tutorial:blocks/keyhole_front"</span><span class="color--orang">,</span><br>
                        <span class="color--violet">"down"</span><span class="color--orang">:</span> <span class="color--green">"tutorial:blocks/keyhole_side"</span><span class="color--orang">,</span><br>
                        <span class="color--violet">"up"</span><span class="color--orang">:</span> <span class="color--green">"tutorial:blocks/keyhole_side"</span><span class="color--orang">,</span><br>
                        <span class="color--violet">"east"</span><span class="color--orang">:</span> <span class="color--green">"tutorial:blocks/keyhole_side"</span><span class="color--orang">,</span><br>
                        <span class="color--violet">"west"</span><span class="color--orang">:</span> <span class="color--green">"tutorial:blocks/keyhole_side"</span><span class="color--orang">,</span><br>
                        <span class="color--violet">"north"</span><span class="color--orang">:</span> <span class="color--green">"tutorial:blocks/keyhole_front"</span><span class="color--orang">,</span><br>
                        <span class="color--violet">"south"</span><span class="color--orang">:</span> <span class="color--green">"tutorial:blocks/keyhole_side"</span></div>
                      }
                    </div>
                    }
                </div>
                <div class="info">
                    <p>Во-первых, мы, в качестве базовой модели, используем как раз <b>cube</b>, а не <b>cube_all</b>, так как нам важно задать текстуру для каждой стороны, а не одну текстуру на все стороны, как это было в случае с <b>cube_all</b>. В описании этой модели, мы так же, определяем текстуру для частичек, которые вылетают из блока при его разрушении</p>
                    <p>Во-вторых, мы используем одну и ту же текстуру для всех сторон <span style="color: #ccc">(я назвал ее <b>keyhole_side</b>)</span>, кроме <b>«лицевой»</b> <span style="color: #ccc">(которую я называл <b>keyhole_front</b>)</span></p>
                </div>
                <p>Ну и сами текстуры либо рисуем, либо берем мои:</p>
                <div id="keyhole_front" class="image--donwload"><p class="image--info" style="background-image: url(https://dmitry-407.github.io/zig/download/keyhole_front.png)"></p><a download href="https://dmitry-407.github.io/zig/download/keyhole_front.png">Скачать</a></div>
                <div id="keyhole_side" class="image--donwload"><p class="image--info" style="background-image: url(https://dmitry-407.github.io/zig/download/keyhole_side.png)"></p><a download href="https://dmitry-407.github.io/zig/download/keyhole_side.png">Скачать</a></div>
                <p>Что я забыл? Правильно, добавить локализацию названия блока:</p>
                <div class="code">tile.tutorial.keyhole.name=Keyhole</div>
                <p class="imag" style="background-image: url(https://pp.userapi.com/c856120/v856120288/9b733/e7WukiotG9E.jpg); height: 300px;" onclick="image('https://pp.userapi.com/c856120/v856120288/9b733/e7WukiotG9E.jpg')"></p>
                <p>В следующей статье мы научимся генерировать нашу руду в мире, рассмотрим, как из руды получить слитки при помощи пережарки в печке, напишем рецепт для ключа и заставим наш блок с замочной скважиной менять свое состояние, если мы его «открываем» ключом, и выдавать редстоун сигнал</p>
                <a href="https://dmitry-407.github.io/zig/code/3/web" class="donwload">Исходники</a>
            </div>
        </div>
        <div class="window"></div>
        <p class="up" onclick="up()"></p>
        <footer>
            <div class="content">
                <p class="avtor">Автор используемых материалов <a href="https://vk.com/zigthehedge">ZigTheHedge</a></p>
                <p class="image">Используются изображения с <a href="https://www.minecraft.net">Minecraft.net</a></p>
                <p class="dev">Разработано <a href="https://vk.com/demon_407">dmitry Popov</a></p>
            </div>
        </footer>
        <script src="/zig/script.js" type="text/javascript"></script>
    </body>
</html>